<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Báo cáo tổng hợp</title>
  <style>
    /*style mở ra một khu vực để viết mã CSS*/
    body {
    font-family: Arial, sans-serif;
    margin: 0;
    padding: 0;
  }
  
center {
    margin-top: 50px;
  }
  
form {
    width: 50%;
    margin: auto;
  }
  
h1, h3 {
    text-align: center;
  }
  
input[type="submit"] {
    width: 100%;
    margin-bottom: 10px;
  }


textarea {
    width: 100%; /* Đặt chiều rộng của textarea là 100% của container */
    
}

.textarea-container {
    display: flex;
    justify-content: space-between;
}

.textarea-group {
    width: 48%; /* Điều chỉnh chiều rộng của mỗi textarea-group */
}


  
input[type="radio"] {
    margin-right: 5px;
  }
  
header {
    background-color: #333;
    color: #fff;
    padding: 11px;
    text-align: center;
    margin-bottom: 20px;
}

header h1 {
    margin: 0;
}

header p {
    margin: 10px 0 0;
}

.selector-container {
    display: flex;
    flex-wrap: nowrap;
    justify-content: space-between; /* Đặt khoảng cách giữa các phần tử */

    width: 45%; /* Đặt chiều rộng của container */
    margin-left: 435px;
    margin-bottom: 20px; /* Thêm margin dưới container */
}

label, select, button {
    margin-right: 20px; /* Thay đổi giá trị này để điều chỉnh khoảng cách */
    margin-bottom: 10px; /* Thay đổi giá trị này để điều chỉnh khoảng cách */
}



/* Thêm CSS cho nút "Xem" và nút "Submit" */
button {
    background-color: #008CBA; /* Màu nền */
    color: white; /* Màu chữ */
    padding: 10px 20px; /* Độ lớn của nút */
    border: none; /* Bỏ viền */
    border-radius: 5px; /* Bo tròn góc */
    cursor: pointer; /* Hiển thị con trỏ khi di chuột vào nút */
}

/* Thêm hover effect khi di chuột vào nút */
button:hover {
    background-color: #007399;
}
/* Thêm CSS cho input[type="submit"] */
input[type="submit"] {
    background-color: #008CBA; /* Màu nền */
    color: white; /* Màu chữ */
    padding: 10px 20px; /* Độ lớn của nút */
    border: none; /* Bỏ viền */
    border-radius: 5px; /* Bo tròn góc */
    cursor: pointer; /* Hiển thị con trỏ khi di chuột vào nút */
}

/* Thêm hover effect khi di chuột vào input[type="submit"] */
input[type="submit"]:hover {
    background-color: #007399;
}
/* Thêm CSS cho mục "Chọn tuần" và "Chọn bài" */
.custom-select {
    display: block;
    width: 100%;
    padding: 10px;
    font-size: 16px;
    line-height: 1.3;
    color: #555;
    background-color: #f9f9f9;
    border: 1px solid #ccc;
    border-radius: 5px;
    box-sizing: border-box;
    margin-bottom: 10px;
}

/* Hiệu ứng hover */
.custom-select:hover {
    background-color: #f9f9f9;
    box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
}

/* Thêm CSS cho label */
label {
    display: block;
    font-weight: bold;
    margin-bottom: 5px;
}

.lang{
    display: block;
    width: 100%;
    padding: 10px;
    font-size: 16px;
    line-height: 1.3;
    color: #555;
    background-color: #f9f9f9;
    border: 1px solid #ccc;
    border-radius: 5px;
    box-sizing: border-box;
    margin-bottom: 10px;
}
</style>
</head>
<body>
    <header>
        <h1>Báo cáo Project 1</h1>
        <p>Nguyễn Nam Hoàng 20215382</p>
    </header>
    <div class="selector-container">
        <label for="weekSelector">Chọn tuần:</label>
        <select id="weekSelector" class="custom-select" onchange="updateBaiSelector()">
            <option value=""></option>
            <option value="1">Tuần 1</option>
            <option value="2">Tuần 2</option>
            <option value="3">Tuần 3</option>
            <option value="4">Tuần 4</option>
            <option value="5">Tuần 5</option>
            <option value="6">Tuần 6</option>
            <option value="7">Tuần 7</option>
            <option value="8">Tuần 8</option>
        </select>

        <label for="baiSelector">Chọn bài:</label>
        <select id="baiSelector" class="custom-select">
            <!-- Options sẽ được thêm bằng JavaScript dựa trên lựa chọn của "Chọn tuần" -->
        </select>

        <button onclick="showCode()">Xem</button>
    </div>

    
    <form id="myform" name="myform" method="post" action="compilecode" target="_blank" >
        <div class="textarea-container">
            <div class="textarea-group">
                <h3>Đề bài</h3>
                <textarea rows="10" cols="100" id="problem" name="problem" class="problem"></textarea>
            </div>
    
            <div class="textarea-group">
                <h3>Code</h3>
                <textarea rows="10" cols="100" id="code"  name="code" class="code"></textarea>
            </div>
        </div>

        <div class="textarea-container">
            <div class="textarea-group">
                <h3>Input</h3>
                <textarea rows="10" cols="100" id="input" name="input"></textarea>
            </div>
    
            <div class="textarea-group">
                <h3>Output</h3>
                <textarea rows="10" cols="100" id="output" name="output"></textarea>
            </div>
        </div>
      Language :
      <select name="lang" class="lang">
        <option value="C++">C++</option>
        <option value="Python">Python</option>
      </select>

      <input type="submit" value="submit" name="submit" onclick="delayedShowOutput()"/>
    </form>

    <script>
      (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})
      ()
      ({1:[function(require,module,exports){

},{}],2:[function(require,module,exports){
    
  var fs = require('fs');
  function delayedShowOutput() {
    // Chờ 2 giây trước khi gọi showOutPut
    setTimeout(showOutPut, 500);
}
  function showOutPut() {
    var data = fs.readFileSync("/", {encoding:'utf8'});
    console.log(data);
  }

},{"fs":1}]},{},[2]);
function delayedShowOutput() {
    // Chờ 2 giây trước khi gọi showOutPut
    setTimeout(showOutPut, 2000);
}
function showOutPut() {
     const xhttp = new XMLHttpRequest();
     xhttp.onload = function() {
         document.getElementById('output').innerHTML = this.responseText;
     }
     xhttp.open('GET', 'http://127.0.0.1:5500/temp/temp.txt', true);
     xhttp.send();
  }

function updateBaiSelector() {
    var weekSelector = document.getElementById("weekSelector");
    var baiSelector = document.getElementById("baiSelector");

    // Xóa tất cả các options hiện tại trong baiSelector
    baiSelector.innerHTML = "";

    // Lấy giá trị của tuần được chọn
    var selectedWeek = weekSelector.value;

    // Số lượng bài tương ứng với mỗi tuần (đã biết từ trước)
    var baiCount = {
        "1": 14,
        "2": 7,
        "3":9,
        "4":4,
        "5":4,
        "6":3,
        "7":2,
        "8":2
        // Thêm các tuần khác nếu cần
    };

    // Tạo các option cho baiSelector dựa trên số lượng bài của tuần được chọn
    for (var i = 1; i <= baiCount[selectedWeek]; i++) {
        var option = document.createElement("option");
        option.value = i;
        option.text = "Bài " + i;
        baiSelector.add(option);
    }
}

var problemStatements = {
    "1_1": 
`Given a sequence of integers a1, a2, ..., an. Compute the sum Q of elements of this sequence.
Input
Line 1: contains n (1 <= n <= 1000000)
Line 2: contains a1, a2, ..., an (-10000 <= ai <= 10000)
Output
Write the value of Q
Example
Input
4
3 2 5 4
Output
14    
`, "1_2":
`Given a positive integer n, find all integer having 3 digits which is divisible by n.
Input
Line 1: contains a positive integer n (1 <= n <= 999)
Output
Write the sequence of numbers found (elements are separated by a SPACE character)

Example
Input 
200

Output 
200 400 600 800
`, "1_3":
`Hiện tại giá điện đang được tính theo bậc thang gồm 6 mức (mức điều chỉnh từ 04/05/2023), với giá thấp nhất (bậc 1) là 1.728VND và giá bậc cao nhất là 3.015 VND. Tuy nhiên EVN đang đề xuất một cách tính giá điện bậc thang mới chỉ gồm 5 mức như hinh dưới, giá thấp nhất (bậc 1) khoảng 1.728 đồng một kWh và cao nhất (bậc 5) là 3.457 đồng một kWh. 

Bậc	Biểu giá hiện hành	Phương án 5 bậc
  	Mức sử dụng	Giá (*)	Mức sử dụng	Giá
1	0-50 kWh	1.728	0-100 kWh	1.728
2	51-100 kWh	1.786	101-200 kWh	2.074
3	101-200 kWh	2.074	201-400 kWh	2.612
4	201-300 kWh	2.612	401-700 kWh	3.111
5	301-400 kWh	2.919	701 kWh trở lên	3.457
6  	401 kWh trở lên	3.015		
(*) Giá chưa bao gồm thuế VAT

Hãy xây dựng chương trình nhập vào số kwh điện của một hộ tiêu thụ và so sánh xem theo bảng giá mới đang lấy ý kiến thì tiền điện tiêu thụ của hộ đó sẽ tăng thêm hay giảm đi bao nhiêu.

INPUT: là số kwh điện tiêu thụ của hộ (là số nguyên)
OUTPUT: là chênh lệch giữa giá theo đề xuất và giá theo mô hình bậc thang 6 mức đang được áp dụng.

VAT sẽ được lấy là 10%, và kết quả in ra sẽ lấy tới 2 chữ số thập phân

EXAMPLE 
INPUT
540
OUTPUT
-22176.00


INPUT
70
OUTPUT
-1276.00
`, "1_4": 
`Given a TEXT, write a program that converts the TEXT to upper-case. 

Input
The TEXT

Output
The TEXT in which characters are converted into upper-case

Example 
Input 
Hello John,
How are you?

Bye,

Output 
HELLO JOHN,
HOW ARE YOU?

BYE, 
`, "1_5": 
`Given a date which is a string under the format YYYY-MM-DD (in which YYYY is the year, MM is the month (the month í from 1 to 12), and DD is the date (the date is from 1 to 31)). Extract the year, month and date.
Input
Line 1: contains a string s  
Output
if s is not under the format YYYY-MM-DD, then write INCORRECT. Otherwise, write year, month, and date separated by a SPACE character

Example
Input
2023-10-04
Output
2023 10 4


Input
2023-10-4
Output
INCORRECT 

Input
2023-10 04
Output
INCORRECT
`, "1_6": 
`Given an integer n, print numbers from 1 to n and its squares.
Input
Line 1: contains a positive integer n (1 <= n <= 100)
Output
Each line i (i = 1,...,n): contains i and i^2 (elements are separated by one SPACE character)

Example
Input
3
Output
1 1
2 4
3 9
`, "1_7": 
`Given a sequence of integer a1, a2, ..., an. Count the number of odd elements and even elements of the sequence.
Input
Line 1: contains a positive integer n (1 <= n <= 100000)
Line 2: contains a1, a2, ..., an. (1 <= ai <= 1000000)
Output
Write the number of odd elements and the number of even elements (separated by a SPACE character)

Example 
Input 
6
2 3 4 3 7 1
Output 
4 2
`, "1_8": 
`Given 2 integers a and b. Compute a+b, a-b, a*b, a/b.
Input
Line 1 contains 2 integers a and b (1 <= a,b <= 1000)
Output
Write a+b, a-b, a*b, a/b  (4 integers are separated by a SPACE characters)

Example
Input
9 4

Output 
13 5 36 2
`, "1_9": 
`Given a time moment which is a string under the format hh:mm:ss (in which hh (0 <= hh <= 23) is the hour, mm (0 <= mm <= 59) is the minute, and ss (0 <= ss <= 59) is the second). Convert this time moment in seconds (result = hh*3600 + mm*60 + ss).
Input
Line 1: contains a string s representing the time moment.  
Output
if s is not under the format hh:mm:ss, then write INCORRECT. Otherwise, write value converted.

Example
Input
13:05:26

Output
47126


Input
13:05:6

Output
INCORRECT 

Input
13:05 26

Output
INCORRECT
`, "1_10": 
`Given an equation ax^2 + bx + c = 0. Find solution to the given equation.
Input
Line 1 contains 3 integers a, b, c 
Output
Write NO SOLUTION if the given equation has no solution 
Write x0 (2 digits after the decimal point) if the given equation has one solution x0 
Write x1 and x2 with x1 < x2 (2 digits after the decimal point) if the given equation has two distinct solutions x1, x2 

Example
Input 
1 1 8
Output 
NO SOLUTION 


Input 
1 -2 1
Output
1.00

Input 
1 -7 10
Output 
2.00 5.00
`, "1_11": 
`Given a sequence of integers a1, a2, ..., an. Perform a sequence of queries over this sequence including:
find-max: return the maximum element of the given sequence
find-min: return the minimum element of the given sequence 
sum: return the sum of the elements of the given sequence 
find-max-segment i j: return the maximum element of the subsequence from index i to index j (i <= j)

Input
The first block contains the information about the given sequence with the following format:
Line 1: contains a positive integer n (1 <= n <= 10000)
Line 2: contains n integers a1, a2, ..., an (-1000 <= ai <= 1000)
The first block is terminated by a character *
The second block contains a sequence of queries defined above, each query is in a line. The second block is terminated a 3 characters ***

Output
Write the result of each query in a corresponding line
 
Example
Input
5
1 4 3 2 5
*
find-max
find-min
find-max-segment 1 3
find-max-segment 2 5
sum
***

Output
5
1
4
5
15
`, "1_12": 
`Given a sequence of integers a1, a2, . . ., an. A k-subsequence is define to be a sequence of k consecutive elements: ai, ai+1, . . ., ai+k-1. The weight of a k-subsequence is the sum of its elements.
Given positive integers k and m. Compute the number Q of k-subsequences such that the weight is even.
Input
Line 1: contains 2 positive integers n, k (1 <= n <= 100000, 1 <= k <= n/2)
Line 2: contains a1, a2, . . ., an. (1 <= ai <= 10000)
Output
Write the value Q
Example
Input
6  3
2 4 5 1 1 2 
Output
2
`, "1_13": 
`Given a Text, write a prorgam to count the number Q of words (ignore characters SPACE, TAB, LineBreak) of this Text

Input
The Text

Output
Write the number Q of words

Example
Input
Hanoi University Of Science and Technology
School of Information and Communication Technology


Output
12
`, "1_14": 
`Cho văn bản T và 2 mẫu P1, P2 đều là các xâu ký tự (không chứa ký tự xuống dòng, độ dài không vượt quá 1000). Hãy thay thế các xâu P1 trong T bằng xâu P2.
Dữ liệu
· Dòng 1: xâu P1
· Dòng 2: xâu P2
· Dòng 3: văn bản T
Kết quả:
· Ghi văn bản T sau khi thay thế
Ví dụ
Dữ liệu
AI
Artificial Intelligence
Recently, AI is a key technology. AI enable efficient operations in many fields.
Kết quả
Recently, Artificial Intelligence is a key technology. Artificial Intelligence enable efficient operations in many fields.
`, "2_1": 
`Given a fibonacci sequence a[0], a[1], a[2], ... in which:  a[0] = 0, a[1] = 1, a[n] = a[n-1] + a[n-2], for all n >= 2
Given  positive integer n, compute a[n-1].
Input
Line 1: contains a positive integer n (2 <= n <= 21)
Output
Write a[n-1]
Example
Input
9
Output
21
`, "2_2": 
`Given two positive integers k and n. Compute C(k,n) which is the number of ways to select k objects from a given set of n objects.
Input
Line 1: two positive integers k and n (1 <= k,n <= 999)
Output
Write te value C(k,n) modulo 10
9
+7.
Example
Input
3  5
Output
10
`, "2_3": 
`Given an integer n, write a program that generates all the binary sequences of length n in a lexicographic order.
Input
Line 1: contains an integer n (1 <= n <= 20)
Output
Write binary sequences in a lexicographic ordder, eac sequence in a line

Example
Input
3
Output
000
001
010
011
100
101
110
111
`, "2_4": 
`Given an integer n, write a program that generates all binary sequences without consecutive 11 in a lexicographic order.
Input
Line 1: contains an integer n (1 <= n <= 20)
Output
Write binary sequences in a lexicographic order, each sequence in a line
Example
Input
3
Output
000
001
010
100
101
`,"2_5": 
`Given an integer n, write a program to generate all permutations of 1, 2, ..., n in a lexicalgraphic order (elements of a permutation are separated by a SPACE character).
Example
Input 
3
Output
1 2 3 
1 3 2 
2 1 3 
2 3 1 
3 1 2 
3 2 1 
`, "2_6": 
`Write a program to compute the number of sudoku solutions (fill the zero elements of a given partial sudoku table)
Fill numbers from 1, 2, 3, .., 9 to 9 x 9 table so that:
Numbers of each row are distinct
Numbers of each column are distinct
Numbers on each sub-square 3 x 3 are distinct
Input
Each line i (i = 1, 2, ..., 9) contains elements of the i
th
 row of the Sudoku table: elements are numbers from 0 to 9 (value 0 means the empty cell of the table)
Output
Write the number of solutions found

Example
Input
0 0 3 4 0 0 0 8 9
0 0 6 7 8 9 0 2 3
0 8 0 0 2 3 4 5 6
0 0 4 0 6 5 0 9 7
0 6 0 0 9 0 0 1 4
0 0 7 2 0 4 3 6 5
0 3 0 6 0 2 0 7 8
0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0
Output
64
`, "2_7": 
`Give two integer n and M. Write a program that generates all orderd collections(X1, X2, ..., Xn) such that X1+X2+...+Xn = M
Input
Line 1: contains 2 integers n and M
Output
Write in each line X1, X2, ..., Xn seperated by a SPACE character

Example
Input
3 5
Output
1 1 3
1 2 2
1 3 1
2 1 2
2 2 1
3 1 1
`, "3_1": 
`Perform a sequence of operations over a stack, each element is an integer:
PUSH v: push a value v into the stack
POP: remove an element out of the stack and print this element to stdout (print NULL if the stack is empty)
Input
Each line contains a command (operration) of type 
PUSH  v
POP
Output
Write the results of POP operations (each result is written in a line)
Example
Input
PUSH 1
PUSH 2
PUSH 3
POP
POP
PUSH 4
PUSH 5
POP
#
Output
3
2
5
`, "3_2": 
`Perform a sequence of operations over a queue, each element is an integer:
PUSH v: push a value v into the queue
POP: remove an element out of the queue and print this element to stdout (print NULL if the queue is empty)
Input
Each line contains a command (operration) of type
PUSH  v
POP
Output
Write the results of POP operations (each result is written in a line)
Example
Input
PUSH 1
PUSH 2
PUSH 3
POP
POP
PUSH 4
PUSH 5
POP
#
Output
1
2
3

Input
PUSH 1
POP
POP
PUSH 4
POP
#
Output
1
NULL
4
`, "3_3": 
`Given a string containing only characters (, ), [, ] {, }. Write a program that checks whether the string is correct in expression.
Example
 ([]{()}()[]): correct
 ([]{()]()[]): incorrect
Input
One line contains the string (the length of the string is less than or equal to $10^6$)One line contains the string (the length of the string is less than or equal to 10
6
)
Output
Write 1 if the sequence is correct, and write 0, otherwise
Example
Input
(()[][]{}){}{}[][]({[]()})
Output
1
`, "3_4": 
`There are two jugs, a-litres jug and b-litres jug (a, b are positive integers). There is a pump with unlimited water. Given a positive integer c, how to get exactly c litres.
Input
   Line 1: contains positive integers a,   b,  c  (1 <= a, b, c <= 900)
Output
  write the number of steps or write -1 (if no solution found)
Example

Input
6  8  4
Output
4
`, "3_5": 
`Mỗi nút trên cây có trường id (identifier) là một số nguyên (id của các nút trên cây đôi một khác nhau)
Thực hiện 1 chuỗi các hành động sau đây bao gồm các thao tác liên quan đến xây dựng cây và duyệt cây
· MakeRoot u: Tạo ra nút gốc u của cây
· Insert u v: tạo mới 1 nút u và chèn vào cuối danh sách nút con của nút v (nếu nút có id bằng v không tồn tại hoặc nút có id bằng u đã tồn tại thì không chèn thêm mới)
· PreOrder: in ra thứ tự các nút trong phép duyệt cây theo thứ tự trước
· InOrder: in ra thứ tự các nút trong phép duyệt cây theo thứ tự giữa
· PostOrder: in ra thứ tự các nút trong phép duyệt cây theo thứ tự sau
Dữ liệu: bao gồm các dòng, mỗi dòng là 1 trong số các hành động được mô tả ở trên, dòng cuối dùng là * (đánh dấu sự kết thúc của dữ liệu).
Kết quả: ghi ra trên mỗi dòng, thứ tự các nút được thăm trong phép duyệt theo thứ tự trước, giữa, sau của các hành động PreOrder, InOrder, PostOrder tương ứng đọc được từ dữ liệu đầu vào
Ví dụ
Dữ liệu
MakeRoot 10
Insert 11 10
Insert 1 10
Insert 3 10
InOrder
Insert 5 11
Insert 4 11
Insert 8 3
PreOrder
Insert 2 3
Insert 7 3
Insert 6 4
Insert 9 4
InOrder
PostOrder
*
Kết quả
11 10 1 3
10 11 5 4 1 3 8
5 11 6 4 9 10 1 8 3 2 7
5 6 9 4 11 1 8 2 7 3 10
`, "3_6": 
`Given a family tree represented by child-parent (c,p) relations in which c is a child of p. Perform queries about the family tree:
descendants <name>: return number of descendants of the given <name>
generation <name>: return the number of generations of the descendants of the given <name>

Note that: the total number of people in the family is less than or equal to 10
4
Input
Contains two blocks. The first block contains information about child-parent, including lines (terminated by a line containing ***), each line contains: <child> <parent> where <child> is a string represented the name of the child and <parent> is a string represented the name of the parent. The second block contains lines (terminated by a line containing ***), each line contains two string <cmd> and <param> where <cmd> is the command (which can be descendants or generation) and <param> is the given name of the person participating in the  query.
Output
Each line is the result of a corresponding query.
Example
Input
Peter Newman
Michael Thomas
John David
Paul Mark
Stephan Mark
Pierre Thomas
Mark Newman
Bill David
David Newman
Thomas Mark
***
descendants Newman
descendants Mark
descendants David
generation Mark
***
Output
10
5
2
2
`, "3_7": 
`Given a BST initialized by NULL. Perform a sequence of operations on a BST including:
insert k: insert a key k into the BST (do not insert if the key k exists)
Input
•Each line contains command under the form: “insert k”
•The input is terminated by a line containing #
Output
•Write the sequence of keys of nodes visited by the pre-order traversal (separated by a SPACE character)
Example
Input
insert 20
insert 10
insert 26
insert 7
insert 15
insert 23
insert 30
insert 3
insert 8
#
Output
20 10 7 3 8 15 26 23 30
`, "3_8": 
`Give a sequence of integers a1, a2,...,an. The element in the middle is defined to be the element at index n/2 if even, n/2 + 1 if odd
Perform a sequence of action of the form:
ADD v: add a value v right after the element in the middle
PRINT: print the sequence to stdout

INPUT
Line 1: contain a positive integer n
Line 2: contain n positve integers
Subsequent lines, each line contains an action of above format

OUTPUT:
Write the result of the correspond PRINT action

Example
Input
2
8 4 
ADD 6
ADD 5
ADD 4
PRINT
ADD 2
ADD 4
PRINT
#

Output
8 6 4 5 4
8 6 4 4 2 5 4
`, "3_9": 
`Viết chương trình thực hiện công việc sau:
Xây dựng danh sách liên kết với các khóa được cung cấp ban đầu là dãy a1, a2, ..., an
Sau đó thực hiện các thao tác trên danh sách bao gồm: thêm 1 phần tử vào đầu, vào cuối danh sách, hoặc vào trước, vào sau 1 phần tử nào đó trong danh sách, hoặc loại bỏ 1 phần tử nào đó trong danh sách

Input
Dòng 1: ghi số nguyên dương n (1 <= n <= 1000)
Dòng 2: ghi các số nguyên dương a
1
, a
2
, …, a
n
.
Các dòng tiếp theo lần lượt là các lệnh để thao tác (kết thúc bởi ký hiệu #) với các loại sau:
addlast  k: thêm phần tử có key bằng k vào cuối danh sách (nếu k chưa tồn tại)
addfirst  k: thêm phần tử có key bằng k vào đầu danh sách (nếu k chưa tồn tại)
addafter  u  v: thêm phần tử có key bằng u vào sau phần tử có key bằng v trên danh sách (nếu v đã tồn tại trên danh sách và u chưa tồn tại)
addbefore  u  v: thêm phần tử có key bằng  u vào trước phần tử có key bằng v trên danh sách (nếu v đã tồn tại trên danh sách và u của tồn tại)
remove  k: loại bỏ phần tử có key bằng k khỏi danh sách
reverse: đảo ngược thứ tự các phần tử của danh sách (không được cấp phát mới các phần tử, chỉ được thay đổi mối nối liên kết)
Output
Ghi ra dãy khóa của danh sách thu được sau 1 chuỗi các lệnh thao tác đã cho

Example
Input
5
5 4 3 2 1
addlast 3
addlast 10
addfirst 1
addafter 10 4
remove 1
#

Output
5 4 3 2 10 
`, "4_1": 
`A database contains a sequence of key k1, k2, ..., kn which are strings (1<=n<=100000). Perform a sequence of actions of two kinds:
· find k: find and return 1 if k exists in the database, and return 0, otherwise
· insert k: insert a key k into the database and return 1 if the insertion is successful (k does not exist in the database) and return 0 if the insertion is failed (k exists in the database)
Note that the length of any key is greater than 0 and less than or equal to 50.
Input
Two blocks of information. The first block contains a key of (k1,k2,...,kn) in each line. The first block is terminated with a line containing *. The second block is a sequence of actions of two finds described above: each line contains 2 string: cmd and k in which cmd = find or insert and k is the key (parameter of the action). The second block is terminated with a line containing ***. Note that the number of actions can be up to 100000.
Output
Each line contains the result (0 or 1) of the corresponding action.
Example
Input
computer
university
school
technology
phone
*
find school
find book
insert book
find algorithm
find book
insert book
***
Output
1
0
1
0
1
0
`, "4_2": 
`Given a string s[1…k] which is a sequence of characters taken from {‘a’, . . ., ‘z’}. Given a positive integer m, the hash code of s is defined by the formula:
H(s) =  (s[1]*256
k-1
 + s[2]*256
k-2
 + . . . + s[k]*256
0 
) mod m  (the contant integer m is a parameter)
Given a sequence of strings k1, k2, …, kn, compute the corresponding hash codes
Input
Line 1: n and m (1 <= n,m <= 100000)
Line i+1 (i = 1,2,…,n): contains the string ki (the length of each string is less than or equal to 200)
Output
Each line contains the corresponding hash code of n given strings
Example
Input
4 1000
a
ab
abc
abcd
Output
97
930
179
924
`, "4_3": 
`Cho dãy số nguyên A1, A2, . . . , An với mỗi số nguyên Ai kiểm tra xem có số Aj nào bằng Ai hay không với j<i.
Input
Dòng đầu chứa số n (1≤n≤100,000)
Dòng hai chứa nn số nguyên A1, A2, ..., An (1≤Ai≤1000,000,000)
Output
Ghi ra n dòng, dòng thứ i in ra 1 nếu tồn tại Aj=Ai với j<i, ngược lại in ra 0.
Example
input
5
1 4 3 1 4
output
0
0
0
1
1
`, "4_4": 
`Cho dãy a1, a2, ..., an trong đó các phần tử đôi một khác nhau và 1 giá trị nguyên dương M. Hãy đếm số Q các cặp (i,j) sao cho 1 <= i < j <= n và ai + aj = M.

Dữ liệu
Dòng 1: ghi n và M (1 <= n, M <= 1000000)
Dòng 2: ghi a1, a2, ..., an
Kết quả
Ghi ra giá trị Q
Ví dụ
Dữ liệu
5 6
5 2 1 4 3
Kết quả
2
`, "5_1": 
`Given a undirected connected graph G=(V,E) where V={1,…,N}. Each edge (u,v)∈E(u,v)∈E has weight w(u,v)w(u,v). Compute minimum spanning tree of G.
Input
Line 1: N and M (1≤N,M≤10
5
) in which NN is the number of nodes and MM is the number of edges.
Line i+1 (i=1,…,M): contains 3 positive integers u, v, and w where w is the weight of edge (u,v)
Output
Write the weight of the minimum spanning tree found.
Example
Input
5 8
1 2 1
1 3 4
1 5 1
2 4 2
2 5 1
3 4 3
3 5 3
4 5 2
Output
7
`, "5_2": 
`Given a undirected graph =(V,E) in which V = {1,2,..,n} is the set of nodes. Write a program that visit nodes of G by a DFS (consider a lexicorgraphic order of nodes).
Input
Line 1: contains 2 integers n and m (1 <= n,m <= 100000)
Line i+1: contains u and v which are two end-points of the ith edge

Output
Sequence of nodes visited by DFS
Example
Input
7 12
1 2
1 3
2 3
2 4
2 7
3 5 
3 7
4 5
4 6
4 7
5 6
5 7 
Output
1 2 3 5 4 6 7
`, "5_3": 
`Given undirected graph G = (V,E) in which V = {1, 2, ..., n} is the set of nodes, and E is the set of m edges.
Write a program that computes the sequence of nodes visited using a BFS algorithm (the nodes are considered in a lexicographic order)

Input
Line 1: contains 2 integers n and m which are the number of nodes and the number of edges
Line i+1 (i = 1, ..., m): contains 2 positive integers u and v which are the end points of the ith edge

Output
Write the sequence of nodes visited by a BFS procedure (nodes a are separated by a SPACE character)
Example

Input
6 7
2 4
1 3
3 4
5 6
1 2
3 5
2 3

Output
1 2 3 4 5 6
`, "5_4": 
`Given an undirected graph G = (V,E). Write a program to check if G is a Hamiltonian graph.
Input
Line 1: a positive integer T (number of graphs)
Subsequent lines are information about T graphs, each has the following format:
Line 1: n and m (number of nodes and edges)
Line i+1 (i = 1, 2, ..., m): u and v : two end points of the ith edge
Output
In the i
th
 line, write 1 if the corresponding is a Hamiltonian graph, and write 0, otherwise
Example
Input
2
5 5
1 2
1 3
2 4
2 5
3 5
7 13
1 3
1 5
1 7
2 4
2 5
2 6
3 4
3 5 
3 7
4 6
4 7
5 7
6 7

Output
0
1
`, 
"6_1": 
`Given a network G = (V, E) which is a directed weighted graph. Node s is the source and node t is the target. c(u,v) is the capacity of the arc (u,v). Find the maximum flow on G.
Input
•Line 1: two positive integers N and M (1 <= N <= 10
4
, 1 <= M <= 10
6
)
•Line 2: contains 2 positive integers s and t
•Line i+2 (I = 1,. . ., M): contains two positive integers u and v which are endpoints of i
th
 arc
Output
  Write the value of the max-flow found
Example
Input
7 12
6 7
1 7 7
2 3 6
2 5 6
3 1 6
3 7 11
4 1 7
4 2 4
4 5 5
5 1 4
5 3 4
6 2 8
6 4 10
Output
17
`, "6_2": 
`Given a directed graph G = (V,E) in which V = {1,2,...,n) is the set of nodes. Each arc (u,v) has a non-negative weight w(u,v). Given two nodes s and t of G. Find the shortest path from s to t on G.
Input
Line 1: contains two integers n and m which are the number of nodes and the number of arcs of G (1 <= n <= 100000)
Line i + 1(i = 1,2,...,m): contains 3 integers u, v, w in which w is the weight of arc(u,v) (0 <= w <= 100000)
Line m+2: contains two integers s and t
Output
Write the weight of the shortest path found or write -1 if no path from s to t was found
Example
Input
5 7
2 5 87
1 2 97
4 5 78
3 1 72
1 4 19
2 3 63
5 1 18
1 5

Output
97
`, 
"6_3": 
`Given a directed graph G = (V, E) in which V = {1, 2, ..., n} is the set of nodes, and w(u,v) is the weight (length) of the arc(u,v). Compute d(u,v) - the length of the shortest path from u to v in G, for all u,v in V.
Input
Line 1: contains 2 positive integers n and m (1 <= n,m <= 10000)
Line i+1 (i = 1, 2, ..., m): contains 3 positive integers u, v, w in which w is the weight of the arc (u,v) (1 <= w <= 1000)
Output
Line i (i = 1, 2, ..., n): wirte the ith row of the matrix d (if there is not any path from node i to node j, then d(i,j) = -1)
Example
Input
4 9 
1 2 9 
1 3 7 
1 4 2 
2 1 1 
2 4 5 
3 4 6 
3 2 2 
4 1 5 
4 2 8
Output
0 9 7 2  
1 0 8 3  
3 2 0 5  
5 8 12 0
`, "7_1": 
`The data about bank transactions consists of a sequence of transactions: the information of each transaction has the following format:
                                                                    <from_account>   <to_account>   <money>   <time_point>   <atm>
In which:
•	<from_account>: the account from which money is transferred (which is a string of length from 6 to 20 )
•	<to_account>: the account which receives money in the transaction (which is a string of length from 6 to 20)
•	<money>: amount of money transferred in the transaction (which is an integer from 1 to 10000)
•	<time_point>: the time point at which the transaction is performed, it is a string under the format HH:MM:SS  (hour: minute: second)
•	<atm>: the code of the ATM where the transaction is taken (a string of length from 3 to 10)
Example: T00112233445 T001234002 2000 08:36:25 BIDV (at the ATM BIDV, account T00112233445 transfers 2000$ to account T001234002 at time point 08:36:25 (08 hour, 36 minutes, 25 seconds) 
A transaction cycle of length k starting from account a1 is defined to be a sequence of distinct account a1, a2, …, ak  in which there are transactions from account a1 to a2, from a2 to a3, …, from ak to a1.
Write a program that process the following queries: 
?number_transactions: compute the total number of transactions of the data
?total_money_transaction: compute the total amount of money of transactions  
?list_sorted_accounts: compute the sequence of bank accounts (including sending and receiving accounts) appearing in the transaction (sorted in an increasing (alphabetical) order)  
?total_money_transaction_from <account>: compute the total amount of money transferred from the account <account>  
?inspect_cycle <account> k : return 1 if there is a transaction cycle of length k, starting from <account>, and return 0, otherwise
Input (stdin)
The input consists of 2 blocks of information: the data block and the query block
•	The data block consists of lines:
o	Each line contains the information about a transaction described above
o	The data is terminated by a line containing #
•	The query block consists of lines:
o	Each line is a query described above
o	The query block is terminated by a line containing #

Output (stdout)
•	Print to stdout (in each line) the result of each query described above

Example
Input
T000010010 T000010020 1000 10:20:30 ATM1
T000010010 T000010030 2000 10:02:30 ATM2
T000010010 T000010040 1500 09:23:30 ATM1
T000010020 T000010030 3000 08:20:31 ATM1
T000010030 T000010010 4000 12:40:00 ATM2
T000010040 T000010010 2000 10:30:00 ATM1
T000010020 T000010040 3000 08:20:31 ATM1
T000010040 T000010030 2000 11:30:00 ATM1
T000010040 T000010030 1000 18:30:00 ATM1
#
?number_transactions
?total_money_transaction
?list_sorted_accounts
?total_money_transaction_from T000010010
?inspect_cycle T000010010 3
#
Output
9
19500
T000010010 T000010020 T000010030 T000010040
4500
1
`, "7_2": 
`Data about sales in an e-commerce company (the e-commerce company has several shops) consists a sequence of lines, each line (represents an order) has the following information:
            <CustomerID> <ProductID> <Price> <ShopID> <TimePoint>
in which the customer <CustomerID> buys a product <ProductID> with price <Price> at the shop <ShopID> at the time-point <TimePoint>
<CustomerID>: string of length from 3 to 10
<ProductID>: string of length from 3 to 10
<Price>: a positive integer from 1 to 1000
<ShopID>: string of length from 3 to 10
<TimePoint>: string representing time-point with the format HH:MM:SS (for example, 09:45:20 means the time-point 9 hour 45 minutes 20 seconds)


Perform a sequence of queries of following types:
?total_number_orders: return the total number of orders
?total_revenue: return the total revenue the e-commerce company gets
?revenue_of_shop <ShopID>: return the total revenue the shop <ShopID> gets 
?total_consume_of_customer_shop <CustomerID> <ShopID>: return the total revenue the shop <ShopID> sells products to customer <CustomerID> 
?total_revenue_in_period <from_time> <to_time>: return the total revenue the e-commerce gets of the period from <from_time> to <to_time> (inclusive)

Input
The input consists of two blocks of data:
The first block is the operational data, which is a sequence of lines (number of lines can be upto 100000), each line contains the information of a submission with above format 
The first block is terminated with a line containing the character #
The second block is the query block, which is a sequence of lines (number of lines can be upto 100000), each line is a query described above
The second block is terminated with a line containing the character #

Output
Write in each line, the result of the corresponding query 

Example
Input
C001 P001 10 SHOP001 10:30:10
C001 P002 30 SHOP001 12:30:10
C003 P001 40 SHOP002 10:15:20
C001 P001 80 SHOP002 08:40:10
C002 P001 130 SHOP001 10:30:10
C002 P001 160 SHOP003 11:30:20
#
?total_number_orders
?total_revenue
?revenue_of_shop SHOP001
?total_consume_of_customer_shop C001 SHOP001 
?total_revenue_in_period 10:00:00 18:40:45
#


Output 
6
450
170
40
370
`, "8_1": 
`Data about submission of a programming contest consists a sequence of lines, each line has the following information:
                                                      <UserID> <ProblemID> <TimePoint> <Status> <Point>
in which the user <UserID> submits his/her code to solve the problem <ProblemID> at time-point <TimePoint>, and gets status <Status> and point <Point>
<UserID>: string of length from 3 to 10
<ProblemID>: string under the format Pxy where x, y are digits 0,1,...,9 (for example P03, P10)
<TimePoint>: string representing time-point with the format HH:MM:SS (for example, 09:45:20 means the time-point 9 hour 45 minutes 20 seconds)
<Status>: string with two cases (ERR, OK)
<Point>: integer from {0, 1, 2, ..., 10}

A user can submit the code for solving each problem several time. The point that the user gets for a problem is the maximal point among the submissions for that problem.

Perform a sequence of queries of following types:
?total_number_submissions: return the number of submissions of the contest
?number_error_submision: return the number of submissions having status ERR 
?number_error_submision_of_user <UserID>: return the number of submission having status ERR of user <UserID> 
?total_point_of_user <UserID>: return the total point of user <UserID> 
?number_submission_period <from_time_point> <to_time_point>: return the number of submissions in the period from <from_time_point> to <to_time_point> (inclusive)

Input
The input consists of two blocks of data:
The first block is the operational data, which is a sequence of lines (number of lines can be up to 100000), each line contains the information of a submission with above format .The first block is terminated with a line containing the character #
The second block is the query block, which is a sequence of lines (number of lines can be up to 100000), each line is a query described above. The second block is terminated with a line containing the character #

Output
Write in each line, the result of the corresponding query 

Example
Input
U001 P01 10:30:20 ERR 0
U001 P01 10:35:20 OK 10
U001 P02 10:40:20 ERR 0
U001 P02 10:55:20 OK 7
U002 P01 10:40:20 ERR 0
U001 P01 11:35:20 OK 8
U002 P02 10:40:20 OK 10
#
?total_number_submissions
?number_error_submision
?number_error_submision_of_user U002 
?total_point_of_user U001 
?number_submission_period 10:00:00 11:30:45
#


Output 
7
3
1
17
6
`, "8_2": 
`CITIZEN
Given a DataBase about citizen, perform queries over this DataBase.
Input
The input consists of two blocks: the first block is the DataBase and the second block is the list of queries. Two blocks are separated by a line containing a character *.
1. The first block (DataBase about citizen) consists of lines (number of lines can be upto 100000), each line is the information about a person and is under the format:
                                   <code>  <dat_of_birth>  <fathher_code>   <mother_code>  <is_alive>  <region_code>
in which:
 <code>: the code of the person which is a string of length 7
 <date_of_birth>: the date of birth of the person and has the format YYYY-MM-DD (for example 1980-02-23), <date_of_birth> is before 3000-12-31
 <fathher_code> and <mother_code> is the code of father and mother: they are also strings of length 7. If the code is 0000000, then the current person does not has information about his father or mother
 <is_alive>: a character with two values: ‘Y’ means that the person is still alive, and ‘N’ means tat the current person is died.
 <region_code>: the code of the region where the person lives

2. The second block is the list of queries (number of queries can be upto 100000) over the DataBase which consists of following commands:
 NUMBER_PEOPLE: return the number of people (number of lines of the DataBase)
 NUMBER_PEOPLE_BORN_AT <date>: return the number of people having date-of-birth is equal to <date>
 MOST_ALIVE_ANCESTOR <code>: find the most ancestor (farthest in term of generation distance) of the given person <code>. Return the generation distance between the ancestor found and the given person
 NUMBER_PEOPLE_BORN_BETWEEN <from_date> <to_date>: compute the number of people having date-of-birth between <from_date> and <to_date> (<from_date> and <to_date> are under the form YYYY-MM-DD, <to_date> is before 3000-12-31)
 MAX_UNRELATED_PEOPLE: find a subset of people in which two any people of the subset do not have father/mother-children and the size of the subset is maximal. Return the size of the subset found.
The second block is terminated by a line containing ***.
Output
 Each line presents the result of the corresponding query (described above).
Example
Input
0000001 1920-08-10 0000000 0000000 Y 00002
0000002 1920-11-03 0000000 0000000 Y 00003
0000003 1948-02-13 0000001 0000002 Y 00005
0000004 1946-01-16 0000001 0000002 Y 00005
0000005 1920-11-27 0000000 0000000 Y 00005
0000006 1920-02-29 0000000 0000000 Y 00004
0000007 1948-07-18 0000005 0000006 Y 00005
0000008 1948-07-18 0000005 0000006 Y 00002
0000009 1920-03-09 0000000 0000000 Y 00005
0000010 1920-10-16 0000000 0000000 Y 00005
*
NUMBER_PEOPLE
NUMBER_PEOPLE_BORN_AT 1919-12-10
NUMBER_PEOPLE_BORN_AT 1948-07-18
MAX_UNRELATED_PEOPLE
MOST_ALIVE_ANCESTOR 0000008
MOST_ALIVE_ANCESTOR 0000001
NUMBER_PEOPLE_BORN_BETWEEN 1900-12-19 1928-11-16
NUMBER_PEOPLE_BORN_BETWEEN 1944-08-13 1977-12-15
NUMBER_PEOPLE_BORN_BETWEEN 1987-01-24 1988-06-03
***
Output
10
0
2
6
1
0
6
4
0
`
};

var codeSnippets = {
      "1_1": `// Nguyễn Nam Hoàng - 20215382
      #include<iostream>
#include<fstream> // Thêm thư viện fstream
using namespace std;

// hàm tính tổng
int final_ans(int *arr, int n) {
    int ans = 0;  // tạo biến lưu kết quả cuối

    // vòng lặp để tính tổng
    for (int i=0;i<n;i++) {
        ans += arr[i];
    }
    return ans; // trả về kết quả
}

int main () {
    int arr[100001];  // khởi tạo mảng arr
    int n; // tạo biến lưu số phần tử của mảng
    cin >> n;

    // vòng lặp để nhập phần tử vào mảng
    for (int i = 0 ; i< n; i++) {
        cin >> arr[i];
    }

    int result = final_ans(arr, n); // Lưu kết quả vào biến result
    cout << result << endl; // in kết quả

    // Tạo và mở file temp.txt
    ofstream outFile("temp.txt");
    
    // Ghi kết quả vào file
    outFile << "Nguyễn Nam Hoàng" << endl;
    outFile << result;

    // Đóng file
    outFile.close();
    
    return 0;
}

`,
      "1_2": `// Nguyễn Nam Hoàng - 20215382
      #include<iostream>
#include<fstream> // Thêm thư viện fstream
using namespace std;

// tạo hàm để tìm số 3 chữ số chia hết cho n
void number_divisible_by_n(int n) {
    int arr[1001]; // khởi tạo mảng để chứa các số cần tìm
    int i = 0; // khởi tạo biến lưu số phần tử của mảng
    int k1 = 100 / n; // biến hỗ trợ cho việc tìm số theo yêu cầu
    int k2 = 999 / n; // biến hỗ trợ cho việc tìm số theo yêu cầu
    for (int j = k1; j <= k2; j++) {
        arr[i++] = j * n; // gán giá trị của mảng arr
    }

    // Tạo và mở file temp.txt
    ofstream outFile("temp.txt");
    outFile << "Nguyễn Nam Hoàng" << endl;

    for (int j = 0; j < i; j++) {
        if (arr[j] == 0 || arr[j] < 100) {continue;} //kiểm tra điều kiện 3 chữ số
        cout << arr[j] << " "; // in kết quả
        
        // Ghi kết quả vào file
        outFile << arr[j] << " ";
    }

    // Đóng file
    outFile.close();
}

int main() {
    int n; // n theo yêu cầu đề bài
    cin >> n; // nhập
    number_divisible_by_n(n); // gọi hàm
    cout << endl; // thêm dòng mới sau khi in kết quả ra console
}

`, "1_3":`// Nguyễn Nam Hoàng - 20215382
#include<iostream>
#include<iomanip>
#include<fstream> // Thêm thư viện fstream
using namespace std;

// hàm tính tiền điện theo cách cũ
double tien_theo_cach_cu(int x) {
    double ans;
    if (x <= 50) {
        ans = x * 1728;
    } else if (x <= 100) {
        ans =  (50 * 1728 + (x - 50) * 1786);
    } else if (x <= 200) {
        ans = (50 * 1728 + 50 * 1786 + (x - 100) * 2074);
    } else if (x <= 300) {
        ans = (50 * 1728 + 50 * 1786 + 100 * 2074 + (x - 200) * 2612);
    } else if (x <= 400) {
        ans = (50 * 1728 + 50 * 1786 + 100 * 2074 + 100 * 2612 + (x - 300) * 2919);
    } else {
        ans = (50 * 1728 + 50 * 1786 + 100 * 2074 + 100 * 2612 + 100 * 2919 + (x - 400) * 3015);
    }
    return ans;
}

// hàm tính tiền điện theo cách mới
double tien_theo_cach_moi(int x) {
    double ans;
    if (x <= 100) {
        ans = x * 1728;
    } else if (x <= 200) {
        ans =  (100 * 1728 + (x - 100) * 2074);
    } else if (x <= 400) {
        ans = (100 * 1728 + 100 * 2074 + (x - 200) * 2612);
    } else if (x <= 700) {
        ans = (100 * 1728 + 100 * 2074 + 200 * 2612 + (x - 400) * 3111);
    } else {
        ans = (100 * 1728 + 100 * 2074 + 200 * 2612 + 300 * 3111 + (x - 700) * 3457);
    }
    return ans;
}

int main () {
    int n; // biến chứa số điện
    cin >> n; // nhập

    double ans = (tien_theo_cach_moi(n) - tien_theo_cach_cu(n)) * 1.1;   // tính tiền điện chênh lệch

    cout << fixed << setprecision(2) << ans << endl; // in kết quả

    // Tạo và mở file temp.txt
    ofstream outFile("temp.txt");
    outFile << "Nguyễn Nam Hoàng" << endl;

    // Ghi kết quả vào file
    outFile << fixed << setprecision(2) << ans;

    // Đóng file
    outFile.close();

    return 0;
}
`, "1_4": `// Nguyễn Nam Hoàng - 20215382
#include<iostream>
#include<string>
#include<vector>
#include<fstream> // Thêm thư viện fstream
using namespace std;

// hàm chuyển kí tự thành in hoa
char change_to_uppercase(char n) {
    if ((int)n >= 97 && (int)n <= 122) { // kiểm tra kí tự có phải là thường không
        int n1 = (int)n - 32; // đổi thành in hoa
        return (char)n1;
    }
    else {
        return n; // nếu không thì giữ nguyên
    }
}

// hàm chuyển 1 chuỗi thành in hoa
string change_to_uppercase_string(string s) {
    int n = s.length(); // lưu độ dài chuỗi
    for (int i = 0; i < n; i++) {
        char k = change_to_uppercase(s[i]); // chuyển từng kí tự
        s[i] = k;
    }
    return s; // trả lại chuỗi đã in hoa
}

int main() {
    string s; // chuỗi để nhập
    vector<string> all; // vecto chứa các kí tự in hoa
    int isEnd = 0; // chưa kt   
    while (getline(cin, s)) // nhập
    {
        if (s.empty()) { // kiểm tra rỗng
            if (isEnd == 2) { // nếu không thấy nhập nữa thì thoát vòng lặp
                break;
            }
            isEnd += 1;
            all.push_back(s);  // đưa chuỗi nhập vào vecto all
        } else {
            string k = change_to_uppercase_string(s); // đưa về in hoa
            all.push_back(k);// đưa chuỗi nhập vào vecto all
            isEnd = 0;
        }
    }

    for (auto i : all) // cho chạy qua từng chuỗi trong vector all
    {
        cout << i << endl; // in ra
    }

    // Tạo và mở file temp.txt
    ofstream outFile("temp.txt");
    outFile << "Nguyễn Nam Hoàng" << endl;

    // Ghi kết quả vào file
    for (auto i : all) {
        outFile << i << endl;
    }

    // Đóng file
    outFile.close();

    return 0;
}

`, "1_5":`// Nguyễn Nam Hoàng - 20215382
#include<iostream>
#include<string>
#include<fstream> // Thêm thư viện fstream
using namespace std;

// kiểm tra chuỗi có hợp lệ không
bool check(string s) {
    int count = 0; // biến đếm kí tự -
    for (int i = 0; i < s.length(); i++) {  // vòng lặp đếm số kí tự - trong chuỗi
        if (s[i] == '-') {
            count++;
        }
    }
    if (count != 2) {
        return false; // nếu số lượng kí tự - khác 2 thì loại
    }
    string s1 = s.substr(0, 4); // chuỗi chỉ số năm
    string s2 = s.substr(5, 2); // chuỗi chỉ số tháng
    string s3 = s.substr(8, 2); // chuỗi chỉ số ngày
    if (s.length() != 10) { // nếu độ dài chuỗi khác 10 thì là không hợp lệ
        return false;
    }
    if (stoi(s2) < 1 || stoi(s2) > 31) { // kiểm tra ngày hợp lệ chưa
        return false;
    }
    if (stoi(s3) < 1 || stoi(s3) > 12) { // kiểm tra tháng hợp lệ chưa
        return false;
    }
    return true;

}

int main() {
    string s; // biến chứa chuỗi
    getline(cin, s); // nhập chuỗi

    // kiểm tra tính hợp lệ của chuỗi
    if (check(s)) {
        string ans = s.substr(0, 4) + ' ' + to_string(stoi(s.substr(5, 2))) + ' ' + to_string(stoi(s.substr(8, 2))); // biến lưu kết quả theo yêu cầu
        cout << ans; // in kết quả

    // Tạo và mở file temp.txt
    ofstream outFile("temp.txt");
    outFile << "Nguyễn Nam Hoàng" << endl;
    
    // Ghi kết quả vào file
    outFile << ans;

    // Đóng file
    outFile.close();
    } else {
        cout << "INCORRECT"; // in nếu chuỗi không hợp lệ
        ofstream outFile("temp.txt");
        outFile << "INCORRECT";
        outFile.close();

    }

    return 0;
}

`, "1_6": `// Nguyễn Nam Hoàng - 20215382
#include<iostream>
#include<fstream> // Thêm thư viện fstream
using namespace std;

// hàm in số theo yêu cầu
void list_number(int n) {
    // Tạo và mở file temp.txt
    ofstream outFile("temp.txt");
    outFile << "Nguyễn Nam Hoàng" << endl;

    for (int i = 1; i <= n; i++) { // vòng lặp để in 
        cout << i << ' ' << i * i << endl; // in số

        // Ghi kết quả vào file
        outFile << i << ' ' << i * i << endl;
    }

    // Đóng file
    outFile.close();
}

int main() {
    int n; // biến lưu giá trị n
    cin >> n; // nhập
    list_number(n); // gọi hàm để thực hiện yêu cầu đề
}
`, "1_7":`// Nguyễn Nam Hoàng - 20215382
#include<iostream>
#include<fstream> // Thêm thư viện fstream
using namespace std;

// hàm thực hiện yêu cầu đề
void final_ans(int *arr, int n) {
    int odd = 0; // lưu số các số lẻ
    int even = 0; // lưu số các số chẵn
    for (int i = 0; i < n; i++) { // lặp toàn bộ mảng
        if (arr[i] % 2 == 0) { // nếu là số chẵn
            even += 1;
        } else { // nếu là số lẻ
            odd += 1;
        }
    }

    cout << odd << ' ' << even << endl; // in ra màn hình

    // Tạo và mở file temp.txt
    ofstream outFile("temp.txt");
    outFile << "Nguyễn Nam Hoàng" << endl;

    // Ghi kết quả vào file
    outFile << odd << ' ' << even << endl;

    // Đóng file
    outFile.close();
}

int main() {
    int n; // số phần tử mảng
    cin >> n; // nhập
    int arr[100001]; // khai báo mảng
    for (int i = 0; i < n; i++) {
        cin >> arr[i]; // nhập mảng
    }
    final_ans(arr, n); // gọi hàm để thực hiện yêu cầu đề bài
}
`, "1_8": `// Nguyễn Nam Hoàng - 20215382
#include<iostream>
#include<fstream> // Thêm thư viện fstream
using namespace std;

int main () {
    int a, b; // khai báo 2 biến tính toán
    cin >> a >> b; // nhập

    // In ra màn hình theo yêu cầu đề
    cout << a + b << ' ' << a - b << ' ' << a * b << ' ' << a / b << endl;

    // Tạo và mở file temp.txt
    ofstream outFile("temp.txt");

    // Ghi kết quả vào file
    outFile << a + b << ' ' << a - b << ' ' << a * b << ' ' << a / b << endl;

    // Đóng file
    outFile.close();

    return 0;
}

`, "1_9":`// Nguyễn Nam Hoàng - 20215382
#include<iostream>
#include<fstream> // Thêm thư viện fstream
#include<string>
using namespace std;

// hàm kiểm tra chuỗi có hợp lệ không
bool check(string s) {
    int count = 0; // biến đếm số kí từ :
    for (int i = 0; i < s.length(); i++) {
        if (s[i] == ':') {
            count++;
        }
    }
    if (count != 2) { // nếu khác 2 chuỗi không hợp lệ
        return false;
    } 
    string s1 = s.substr(0, 2); //  lưu số giờ
    string s2 = s.substr(3, 2); // lưu số phút 
    string s3 = s.substr(6, 2); // lưu số giây
    if (s.length() != 8) { // kiểm tra độ dài kí tự
        return false; // nếu khác 8 , chuỗi không hợp lệ
    }

    if (stoi(s1) < 0 || stoi(s1) > 24) { // kiểm tra giờ hợp lệ
        return false;
    }

    if (stoi(s2) < 0 || stoi(s2) > 59) { // kiểm tra phút hợp lệ
        return false;
    }
    if (stoi(s3) < 0 || stoi(s3) > 59) { // kiểm tra giây hợp lệ
        return false;
    }
    return true;
}

int main () {
    string s;  // biến lưu chuỗi cần xử lý
    getline(cin, s); // nhập chuỗi

    // Tạo và mở file temp.txt
    ofstream outFile("temp.txt");
    outFile << "Nguyễn Nam Hoàng" << endl;

    if (check(s)) {
        int ans = stoi(s.substr(0, 2)) * 3600 +  stoi(s.substr(3, 2)) * 60 +  stoi(s.substr(6, 2)); // điều chỉnh chuỗi theo yêu cầu
        cout << ans; // in chuỗi

        // Ghi kết quả vào file
        outFile << ans;
    } else {
        cout << "INCORRECT"; // chuỗi không hợp lệ thì in INCORRECT

        // Ghi INCORRECT vào file
        outFile << "INCORRECT";
    }

    // Đóng file
    outFile.close();

    return 0;
}
`, "1_10": `// Nguyễn Nam Hoàng - 20215382
#include<iostream>
#include<iomanip>
#include<fstream> // Thêm thư viện fstream
#include<math.h>
using namespace std;

int main() {
    double a, b, c; //  hằng số của phương trình
    cin >> a >> b >> c; // nhập

    double delta = b * b - 4 * a * c;  // khai báo biến delta

    // Tạo và mở file temp.txt
    ofstream outFile("temp.txt");
    outFile << "Nguyễn Nam Hoàng" << endl;

    if (delta == 0) { // kiểm tra điều kiện
        cout << fixed << setprecision(2) << (double)-b / (2 * a);  // in ra nghiệm kép duy nhất

        // Ghi kết quả vào file
        outFile << fixed << setprecision(2) << (double)-b / (2 * a);
    } else if (delta < 0) {  // kiểm tra điều kiện
        cout << "NO SOLUTION"; // in ra không có kết quả

        // Ghi NO SOLUTION vào file
        outFile << "NO SOLUTION";
    } else {
        double ans1 = (double)(-b - sqrt(delta)) / (2 * a); //tính nghiệm thứ 1
        double ans2 = (double)(-b + sqrt(delta)) / (2 * a); //tính nghiệm thứ 2
        cout << fixed << setprecision(2) << ans1 << ' ' << fixed << setprecision(2) << ans2;  // in 2 nghiệm

        // Ghi 2 nghiệm vào file
        outFile << fixed << setprecision(2) << ans1 << ' ' << fixed << setprecision(2) << ans2;
    }

    // Đóng file
    outFile.close();

    return 0;
}
`, "1_11": `// Nguyễn Nam Hoàng - 20215382
#include<iostream>
#include<fstream> // Thêm thư viện fstream
#include<string>
using namespace std;

// hàm tìm giá trị lớn nhất trong mảng
int find_max(int *arr, int n) {
    int ans = -1001; // giá trị cần điều chỉnh để ra kết quả đúng
    for (int i = 0; i < n; i++) { // vòng lặp tìm max
        if (ans < arr[i]) {
            ans = arr[i];
        }
    }
    return ans; // trả về kết quả
}

// hàm tìm giá trị nhỏ nhất trong mảng
int find_min(int *arr, int n) {
    int ans = 1001; // giá trị cần điều chỉnh để ra kết quả đúng
    for (int i = 0; i < n; i++) { // vòng lặp tìm min
        if (ans > arr[i]) {
            ans = arr[i];
        }
    }
    return ans; // trả về kết quả
}

// hàm tính tổng của mảng
int sum(int *arr, int n) {
    int ans = 0; // giá trị cần điều chỉnh để ra kết quả đúng
    for (int i = 0; i < n; i++) { // vòng lặp tính tổng
        ans += arr[i];
    }
    return ans; // trả về kết quả
}

// hàm tìm phần tử lớn nhất trong 1 khoảng nào đó
int find_max_segment(int *arr, int i, int j) { // 5 so 2->5
    int ans = -9999;  // giá trị cần điều chỉnh để ra kết quả đúng
    for (int m = i - 1; m < j; m++) { // vòng lặp tìm
        if (ans < arr[m]) {
            ans = arr[m];
        }
    }
    return ans; // trả về kết quả
}

int main() {
    int n; // biến lưu số phần tử mảng
    int arr[100001]; // khai báo mảng
    string requirements[1001]; // mảng lưu các giá trị input

    int m = 0; // số phần tử mảng requirements

    cin >> n; // nhập số phần tử mảng
    for (int i = 0; i < n; i++) {
        cin >> arr[i];   // nhập phần tử mảng 
    }

    char k;
    cin >> k; // nhập kí tự *

    while (true) {
        string str; // chuỗi theo input
        getline(cin, str); // nhập từng dòng
        if (str == "***") {
            break;
        } else {
            requirements[m++] = str; // thêm chuỗi đã nhập vào mảng chứa yêu cầu
        }
    }

    // Tạo và mở file temp.txt
    ofstream outFile("temp.txt");
    outFile << "Nguyễn Nam Hoàng" << endl;

    for (int i = 0; i < m; i++) { // lặp qua toàn bộ mảng để thực hiện yêu cầu đề bài
        if (requirements[i] == "find-max") {
            cout << find_max(arr, n) << endl;

            // Ghi kết quả vào file
            outFile << find_max(arr, n) << endl;
        }
        if (requirements[i] == "find-min") {
            cout << find_min(arr, n) << endl;

            // Ghi kết quả vào file
            outFile << find_min(arr, n) << endl;
        }
        if (requirements[i] == "sum") {
            cout << sum(arr, n) << endl;

            // Ghi kết quả vào file
            outFile << sum(arr, n) << endl;
        }
        // kiểm tra có phải yêu cầu là find max segment
        if (requirements[i].find("find-max-segment") != string::npos) {
            string segment = requirements[i];
            int space[3], s = 0; // mảng chứa vị trí các dấu cách trong input yêu cầu tìm find-max-segment
            int para1, para2; // khai báo 2 biến cần thiết để thực hiện hàm find-max-segment, s là số phần tử mảng này
            for (int j = 0; j < segment.length(); j++) {
                if (segment[j] == ' ') {
                    space[s++] = j;
                }
            }
            para1 = stoi(segment.substr(space[0] + 1, space[1] - space[0] - 1)); // biến chứa vị trí bắt đầu của mảng con
            para2 = stoi(segment.substr(space[1] + 1, segment.length() - space[1] - 1)); // biến chứa vị trí kết thúc của mảng con
            cout << find_max_segment(arr, para1, para2) << endl;

            // Ghi kết quả vào file
            outFile << find_max_segment(arr, para1, para2) << endl;
        }
    }

    // Đóng file
    outFile.close();

    return 0;
}

`, "1_12": `// Nguyễn Nam Hoàng - 20215382
#include<iostream>
#include<fstream> // Thêm thư viện fstream
using namespace std;

// hàm tính tổng của mảng
int sum(int *arr, int n) {
    int ans = 0; // giá trị cần điều chỉnh để ra kết quả đúng
    for (int i = 0; i < n; i++) { // vòng lặp tính tổng
        ans += arr[i];
    }
    return ans; // trả về kết quả
}

// hàm tính tổng của mảng con từ vị trí i đến j
int sum_sub_arr(int *arr, int i, int j) {
    int ans = 0; // giá trị cần điều chỉnh để ra kết quả đúng
    for (int m = i; m <= j; m++) { // vòng lặp tính tổng
        ans += arr[m];
    }
    return ans; // trả về kết quả
}

int main() {
    int arr[100001]; // khai báo mảng
    int n, m; // biến lưu số phần tử mảng, độ dài mảng con
    int count = 0; // biến đếm chứa kết quả theo yêu cầu
    int answer[100001], j = 0; // khai báo mảng chứa các mảng con có độ dài m và số phần tử của mảng

    cin >> n >> m; // nhập 
    for (int i = 0; i < n; i++) {
        cin >> arr[i];  // nhập phần tử mảng
    }

    int ans = sum_sub_arr(arr, 0, m - 1); // biến chứa kết quả mảng con đầu tiên
    answer[j++] = ans; // lưu vào mảng answer

    for (int i = 1; i <= n - m; i++) { // vòng lặp để tính toán các mảng con
        answer[j++] = ans - arr[i - 1] + arr[i + m - 1];
        ans = answer[j - 1];
    }

    for (int m = 0; m < j; m++) { // vòng lặp tìm số mảng con có tổng chẵn
        if (answer[m] % 2 == 0) {
            count++;
        }
    }

    cout << count; // in kết quả

    // Tạo và mở file temp.txt
    ofstream outFile("temp.txt");
    outFile << "Nguyễn Nam Hoàng" << endl;

    // Ghi kết quả vào file
    outFile << count;

    // Đóng file
    outFile.close();

    return 0;
}
`, "1_13":`// Nguyễn Nam Hoàng - 20215382
#include<iostream>
#include<string>
#include<vector>
#include<fstream> // Thêm thư viện fstream
using namespace std;

// tìm vị trí của chữ đầu tiên trong chuỗi (không tính kí tự space)
int vtchudautien(string str) {
    for (int i = 0; i < str.length(); i++) {  // lặp qua chuỗi
        if (str[i] != ' ') { // thấy space thì ngừng
            return i;
            break;
        }
    }
    return 0;
}

int main() {
    string str; // chuỗi cần nhập

    int isEnd = 0; // chưa kt   
    vector<string> all; // vector chứa input theo yêu cầu đề
    while (getline(cin, str)) // nhập từng dòng
    {

        if (str.empty()) { // nếu chuỗi rỗng (toàn space)

            if (isEnd == 10) { // kiểm tra nếu không còn nhập nữa thì ngừng
                break;
            }
            isEnd += 1;
            all.push_back(str);   // cho chuỗi rỗng vào vector input
        }
        else {
            all.push_back(str);// cho chuỗi vào vector input
            isEnd = 0;
        }
    }
    string str1 = ""; // chuỗi để thực hiện tính trên đó
    for (const string& k : all) {
        str1 += k + " "; // đưa input nhiều dòng thành 1 string chỉ 1 dòng
    }
    int n = str1.length(); // độ dài của chuỗi

    int cnt = 0; // biến đếm word
    int j = 0; // biến hỗ trợ đếm
    for (int i = vtchudautien(str1); i < n; i++) {  // lặp từ vị trí chữ đầu tiên đến hết
        if (str1[i] != ' ') {
            j++;
        }
        else if (str1[i] == ' ' && str1[i + 1] == ' ') { // nếu đến vị trí cách nhau giữa hai từ
            continue;
        }

        else {
            cnt++; // tăng biến đếm từ lên 1
            j = 0;  // reset về 0
        }
    }

    if (j != 0) {
        cnt++;  // tăng biến đếm từ lên 1
    }
    cout << cnt; // in ra kết quả

    // Tạo và mở file temp.txt
    ofstream outFile("temp.txt");
    outFile << "Nguyễn Nam Hoàng" << endl;

    // Ghi kết quả vào file
    outFile << cnt;

    // Đóng file
    outFile.close();

    return 0;
}
`, "1_14":`// Nguyễn Nam Hoàng - 20215382
#include<iostream>
#include<string>
#include<fstream> // Thêm thư viện fstream
using namespace std;

int main () {
    // khai báo 3 chuỗi cần nhập
    string str1;
    string str2;
    string str;

    // nhập 3 chuỗi
    getline(cin, str1);
    getline(cin, str2);
    getline(cin, str);

    int foundarr[1000], m=0; // mảng lưu vị trí các nơi str1 xuất hiện trong str
    int found = str.find(str1); // tìm str1 trong str
    int position = 0; // 
    int length = str.length();

    while (found != string::npos) { // khi vẫn còn tìm thấy str1 trong str
        foundarr[m++] = found; // gán giá trị vào mảng
        // tiếp tục tìm các vị trí xuất hiện tiếp theo của str1
        position = found + 1;
        found = str.find(str1, position);
    }

    string finalans =""; // chuỗi chứa kết quả
    int n=0; // biến kiểm tra đã thay str2 vào str1 lần nào chưa
    int j=0; // biến chạy qua toàn bộ str
    while (j+1 != length) { // while với điều kiện ngừng là chạy hết chuỗi
        if (j==foundarr[n]) { // nếu thấy vị trí str1
            finalans += str2; // thay str1 bằng str2
            j+=str1.length(); // điều chỉnh j 
            n+=1; // đánh dấu đã gặp
        }
        else {
            finalans += str[j++]; // thêm lần lượt các kí tự
        }
    }
    finalans += str[length-1]; // thêm kí tự cuối

    cout << finalans << endl; // in kết quả

    // Tạo và mở file temp.txt
    ofstream outFile("temp.txt");
    outFile << "Nguyễn Nam Hoàng" << endl;
    // Ghi kết quả vào file
    outFile << finalans;

    // Đóng file
    outFile.close();

    return 0;
}
`, "2_1":`// Nguyễn Nam Hoàng - 20215382
#include<iostream>
#include<fstream> // Thêm thư viện để sử dụng fstream
using namespace std;

// hàm tính fibo
int fibo(int n) {
  if (n == 1) return 0; // kiểm tra điều kiện để return
  if (n == 2) return 1; // kiểm tra điều kiện để return
  else {
      return fibo(n-1) + fibo(n-2); // kiểm tra điều kiện để return
  }
}

int main() {
  int n; // biến chứa số cần nhập
  cin >> n; // nhập
  int result = fibo(n); // tính kết quả

  // Mở file temp.txt để ghi kết quả
  ofstream outputFile("temp.txt");
  outFile << "Nguyễn Nam Hoàng" << endl;

  // Kiểm tra xem file có được mở thành công không
  if (outputFile.is_open()) {
    // Ghi kết quả vào file
    outputFile << "Nguyễn Nam Hoàng" << endl;
    outputFile << result << endl;

    // Đóng file
    outputFile.close();

  }
  cout << fibo(n);

  return 0;
}
`, "2_2":`// Nguyễn Nam Hoàng - 20215382
#include<iostream>
#include<fstream> // Thêm thư viện fstream
#include<math.h>
using namespace std;

int arr[10000][10000]; // gọi mảng 2 chiều để lưu các giá trị của C(k,n)

int C(int k, int n) {
    if (k == 0 || k == n) return arr[k][n] = 1; // kiểm tra điều kiện để return
    else {
        if (arr[k][n] < 0) {
            arr[k][n] = (int)(C(k-1, n-1) + C(k, n-1)) % (int)(pow(10, 9) + 7); // gán theo công thức chỉnh hợp 
        }
    }
    return arr[k][n]; // trả về kết quả
}

int main() {
    // gán mọi giá trị trong mảng = -1
    for (int i = 0; i < 1000; i++) {
        for (int j = 0; j < 1000; j++) {
            arr[i][j] = -1;
        }
    }

    int k, n; // lưu các biến cần nhập
    cin >> k >> n; // nhập
    cout << C(k, n) << endl; // in kết quả

    // Tạo và mở file temp.txt
    ofstream outFile("temp.txt");
    outFile << "Nguyễn Nam Hoàng" << endl;

    // Ghi kết quả vào file
    outFile << C(k, n);

    // Đóng file
    outFile.close();

    return 0;
}
`, "2_3": `// Nguyễn Nam Hoàng - 20215382
#include<iostream>
#include<fstream> // Thêm thư viện fstream
using namespace std;

int arr[100];

// hàm để in kết quả ra màn hình
void xuat(int n ) {
    for (int i=0; i<n; i++) {
        cout << arr[i];
    }
    cout << endl;
}

// hàm để tính toán ra kết quả
void ans(int n, int k, ofstream &outFile) {
    // nếu đã đủ số cần xuất, gọi hàm xuat() để in ra màn hình và ghi vào file
    if (k == n) {
        xuat(n);
        for (int i = 0; i < n; i++) {
            outFile << arr[i];
        }
        outFile << endl;
    }
    // nếu chưa đủ
    else {
        // chạy vòng lặp từ 0->1
        for (int i = 0; i <= 1; i++) {
            arr[k] = i; // gán giá trị cho phần tử đang xét
            ans(n, k + 1, outFile); // gọi đệ quy hàm ans
        }
    }
}

int main() {
    int n; // lưu biến cần nhập
    cin >> n; // nhập

    // Tạo và mở file temp.txt
    ofstream outFile("temp.txt");
    outFile << "Nguyễn Nam Hoàng" << endl;
    ans(n, 0, outFile); // thực hiện tính toán theo yêu cầu đề bài

    // Đóng file
    outFile.close();

    return 0;
}

`, "2_4": `// Nguyễn Nam Hoàng - 20215382
#include<iostream>
#include<fstream> // Thêm thư viện fstream
using namespace std;

int arr[100];

// kiểm tra điều kiện không được xuất hiện "11"
bool check(int n) {
    // chạy vòng lặp trong mảng để check
    for (int i = 0; i < n - 1; i++) {
        // nếu thấy "11"
        if (arr[i] == arr[i + 1] && arr[i] == 1) {
            return false;  // trả về sai, break
            break;
        }
    }
    return true;
}

// hàm để in các phần tử trong mảng
void xuat(int n, ofstream& outFile) {
    for (int i = 0; i < n; i++) {
        cout << arr[i]; // in ra màn hình
        outFile << arr[i]; // ghi vào file
    }
    cout << endl;
    outFile << endl;
}

// hàm để tạo kết quả theo yêu cầu đề bài
void ans(int n, int k, ofstream& outFile) {
    // kiểm tra đã đủ số phần tử cần chưa
    if (k == n) {
        // nếu thỏa mãn điều kiện không chứa "11"
        if (check(n)) {
            xuat(n, outFile);
        }
    }
    // nếu chưa đủ số phần tử cần tìm
    else {
        for (int i = 0; i <= 1; i++) {
            arr[k] = i; // gán 1 phần tử của mảng
            ans(n, k + 1, outFile); // gọi đệ quy
        }
    }
}

int main() {
    int n; // biến lưu số cần điền
    cin >> n; // nhập

    // Tạo và mở file temp.txt
    ofstream outFile("temp.txt");
    outFile << "Nguyễn Nam Hoàng" << endl;
    ans(n, 0, outFile); // gọi hàm để thực hiện yêu cầu đề

    // Đóng file
    outFile.close();

    return 0;
}
`, "2_5":
`// Nguyễn Nam Hoàng - 20215382
#include<iostream>
#include<fstream> // Thêm thư viện fstream
using namespace std;

int Bool[15] = { 0 }; //mảng toàn 0 để kiểm tra đã sử dụng phần tử nào
int arr[15]; // mảng chứa các hoán vị

// in các phần tử trong mảng
void xuat(int n, ofstream& outFile) {
    for (int i = 1; i <= n; i++) {
        cout << arr[i] << " ";
        outFile << arr[i] << " "; // Ghi vào file
    }
    cout << endl;
    outFile << endl;
}

// hàm để thực hiện yêu cầu đề
void ans(int k, int n, ofstream& outFile) {
    // vòng lặp để tìm hoán vị
    for (int i = 1; i <= n; i++) {
        //Kiểm tra nếu phần tử chưa được sử dụng 
        if (!Bool[i]) {
            arr[k] = i; // Lưu phần tử vào mảng chứa hoán vị
            Bool[i] = 1;// đổi phần tử mảng bool = 1 để đánh dấu đã dùng
            if (k == n)//Kiểm tra nếu đã đạt đủ số phần tử theo yêu cầu
                xuat(n, outFile);
            else
                ans(k + 1, n, outFile); // ngược lại gọi đệ quy hàm ans
            Bool[i] = 0;
        }
    }
}

int main() {

    int n;  // biến chứa số cần nhập
    cin >> n; // nhập

    // Tạo và mở file temp.txt
    ofstream outFile("temp.txt");
    outFile << "Nguyễn Nam Hoàng" << endl;
    ans(1, n, outFile); // thực hiện yêu cầu đề

    // Đóng file
    outFile.close();

    return 0;
}
`, "2_6":`// Nguyễn Nam Hoàng - 20215382
#include <iostream>
#include <fstream>
using namespace std;

// biến toàn phần để lưu giá trị độ dài hàng, cột
const int N = 9;

// hàm kiểm tra xem có thể đặt giá trị num vào ô có tọa độ (row, col) không
bool check(int board[10][10], int row, int col, int num) {
    // kiểm tra có thỏa mãn điều kiện hàng và cột không
    for (int i = 0; i < N; i++) {
        if (board[row][i] == num || board[i][col] == num) {
            return false; // sai
        }
    }

    // Kiểm tra có thỏa mãn điều kiện hình vuông con không
    int Row0 = row - row % 3;
    int Col0 = col - col % 3;
    for (int i = Row0; i < Row0 + 3;i ++) {
        for (int j = Col0; j < Col0 + 3; j++) {
            if (board[i][j] == num) {
                return false; // sai
            }
        }
    }

    // nếu không gặp phải các ĐK trên, tức là số num thỏa mãn
    return true;
}

// hàm đếm số lượng cách giải
int solveSudoku(int board[10][10]) {
    int row, col;
    bool isEmpty = false; // kiểm tra rỗng
    int solutions = 0; // biến lưu số kết quả

    // tìm ô trống
    for (row = 0; row < N;row ++) {
        for (col = 0; col < N; col++) {
            // nếu phần tử =0
            if (board[row][col] == 0) {
                isEmpty = true; // chưa điền
                break; // break loop trong
            }
        }
        if (isEmpty) {
            break; // break loop ngoài
        }
    }

    // nếu không còn ô trống, tức là đã tìm được 1 cách giải, tăng biến đếm số kết quả và trả về
    if (!isEmpty) {
        solutions++;
        return solutions;
    }

    // điền các số từ 1 đến 9 vào ô trống
    for (int num = 1; num <= 9; num++) {
        // kiểm tra vị trí có thỏa mãn không
        if (check(board, row, col, num)) { // nếu có
            board[row][col] = num; // gán giá trị cho mảng
            solutions += solveSudoku(board); // đệ quy

            // quay lui
            board[row][col] = 0;
        }
    }

    return solutions; 
}

int main() {
    int board[10][10];

    // nhập phần tử trong bảng sudoku
    for (int i = 0; i < N; ++i) {
        for (int j = 0; j < N; ++j) {
            cin >> board[i][j];
        }
    }

    int solutions = solveSudoku(board); // biến lưu kết quả
    cout <<solutions << endl; // in

    // Tạo và mở file temp.txt
    ofstream outFile("temp.txt");
    outFile << "Nguyễn Nam Hoàng" << endl;
    outFile << solutions << endl; // Ghi vào file
    // Đóng file
    outFile.close();

    return 0;
}
`, "2_7":`// Nguyễn Nam Hoàng - 20215382
#include <iostream>
#include <fstream>

using namespace std;

void ans(int n, int M, int arr[10000], int currentSum, int currentIndex, ofstream& outFile) {
    // kiểm trả nếu mảng đã có n phần tử
    if (currentIndex == n) {
        // nếu tổng các phần tử bằng M thì in ra màn hình và ghi vào file
        if (currentSum == M) {
            for (int i = 0; i < n; i++) {
                cout << arr[i] << ' ';
                outFile << arr[i] << ' '; // Ghi vào file
            }
            cout << endl;
            outFile << endl; // Xuống dòng trong file
        }
        return;
    }

    for (int i = 1; i <= M; i++) {
        arr[currentIndex] = i; // gán thử giá trị i vào mảng
        currentSum += i; // cập nhật tổng
        // tiếp tục thử cho phần tử tiếp theo bằng việc gọi đệ quy
        ans(n, M, arr, currentSum, currentIndex + 1, outFile);
        currentSum -= i;// bỏ giá trị i để thử giá trị i+1 thì phải cập nhật lại sum
    }
}

int main() {
    int n, M; // lưu biến cần nhập
    cin >> n >> M; // nhập

    int arr[10000] = {0}; // tạo mảng toàn 0
    int currentSum = 0; // biến lưu tổng tạm thời

    // Tạo và mở file temp.txt
    ofstream outFile("temp.txt");
    outFile << "Nguyễn Nam Hoàng" << endl;
    ans(n, M, arr, currentSum, 0, outFile); // gọi hàm để thực hiện yêu cầu
    
    // Đóng file
    outFile.close();

    return 0;
}
`, "3_1":`// Nguyễn Nam Hoàng - 20215382
#include <iostream>
#include <stack>
#include <string>
#include <fstream>

using namespace std;

int main() {
    stack<int> stack; // khởi tạo stack

    string command; // khai báo biến nhập
    ofstream outFile("temp.txt"); // mở file temp.txt để ghi kết quả
    outFile << "Nguyễn Nam Hoàng" << endl;
    while (cin >> command) { // nhập liên tục
        if (command == "PUSH") { // nếu lệnh PUSH
            int value;
            cin >> value;
            stack.push(value); // đẩy giá trị value vào stack
        } else if (command == "POP") { // nếu lệnh POP
            if (!stack.empty()) { // kiểm tra có rỗng không
                cout << stack.top() << endl; // in ra đỉnh
                outFile << stack.top() << endl; // ghi vào file
                stack.pop(); // lấy phần tử (LIFO)
            } else {
                cout << "NULL" << endl; // in ra nếu stack rỗng
                outFile << "NULL" << endl; // ghi vào file
            }
        }
    }

    // Đóng file
    outFile.close();

    return 0;
}
`, "3_2": `// Nguyễn Nam Hoàng - 20215382
#include <iostream>
#include <queue>
#include <string>
#include <fstream>

using namespace std;

int main() {
    queue<int> queue; // khai báo queue

    string command; // khai báo chuỗi nhập
    ofstream outFile("temp.txt"); // mở file temp.txt để ghi kết quả
    outFile << "Nguyễn Nam Hoàng" << endl;
    while (cin >> command) { // nhập liên tục trong vòng while
        if (command == "#") { // dừng khi gặp #
            break;
        }

        if (command == "PUSH") { // nếu gặp PUSH
            int value;
            cin >> value;
            queue.push(value); // đẩy giá trị value vào queue
        } else if (command == "POP") { // nếu gặp POP
            if (!queue.empty()) { // kiểm tra có rỗng không
                cout << queue.front() << endl; // in ra phần tử đầu queue
                outFile << queue.front() << endl; // ghi vào file
                queue.pop(); // lấy ra phần tử (FIFO)
            } else {
                cout << "NULL" << endl; // in nếu queue rỗng
                outFile << "NULL" << endl; // ghi vào file
            }
        }
    }

    // Đóng file
    outFile.close();

    return 0;
}
`, "3_3":`// Nguyễn Nam Hoàng - 20215382
#include <iostream>
#include <stack>
#include <string>
#include <fstream>

using namespace std;

// hàm kiểm tra ngoặc đúng của chuỗi str
bool isCorrectStr(const string& str) {
    stack<char> stack; // khai báo stack

    for (char c : str) { // vòng lặp trong chuỗi
        if (c == '(' || c == '[' || c == '{') { // kiểm tra điều kiện ngoặc mở
            stack.push(c); // đẩy vào stack
        } else { // ngược lại
            if (stack.empty()) { // nếu rỗng
                return false; // sai
            }

            char top = stack.top(); // gán top bằng phần tử đầu của stack
            stack.pop(); // lấy ra ptu của stack

            if ((c == ')' && top != '(') ||
                (c == ']' && top != '[') ||
                (c == '}' && top != '{')) {  // kiểm tra điều kiện ngoặc đóng
                return false; // sai
            }
        }
    }

    return stack.empty(); // đúng nếu stack rỗng, sai nếu ngược lại
}

int main() {
    string str;
    cin >> str;

    ofstream outFile("temp.txt"); // mở file temp.txt để ghi kết quả
    outFile << "Nguyễn Nam Hoàng" << endl;
    if (isCorrectStr(str)) {
        cout << "1" << endl;
        outFile << "1" << endl; // ghi vào file
    } else {
        cout << "0" << endl;
        outFile << "0" << endl; // ghi vào file
    }

    // Đóng file
    outFile.close();

    return 0;
}

`, "3_4":`// Nguyễn Nam Hoàng - 20215382
#include <iostream>
#include <queue>
#include <unordered_set>
#include <fstream>

using namespace std;

// struct lưu lại trạng thái của ly nước
struct State {
    int x, y;
    int steps;

    // hàm khởi tạo cấu trúc State: State(0,0,0)
    State(int x, int y, int steps) : x(x), y(y), steps(steps) {}
};

// hàm tìm ước chung lớn nhất
int UCLN(int a, int b) {
    return b == 0 ? a : UCLN(b, a % b);
}

// hàm tìm số bước ngắn nhất để ra kết quả
int minSteps(int a, int b, int c) {
    if (c > max(a, b) || c % UCLN(a, b) != 0) {
        return -1; // Không có cách giải
    }

    queue<State> q; // khai báo biến lưu tập các trạng thái kiểu queue
    unordered_set<int> visited; // khai báo biến visited để theo dõi các giá trị đã được thăm, đồng thời tránh lặp lại các trạng thái đã từng có của các bình

    q.push(State(0, 0, 0)); // đưa vào trạng thái đầu tiên của các cốc 
    visited.insert(0); // đưa giá trị đầu tiên vào visited

    while (!q.empty()) {
        State current = q.front();
        q.pop();

        int x = current.x; // biến lưu giá trị hiện tại của bình A
        int y = current.y; // biến lưu giá trị hiện tại của bình B

        // nếu đạt được giá trị cần tìm c, trả về số bước
        if (x == c || y == c) {
            return current.steps;
        }

        // Đổ đầy bình A
        if (x < a) { // kiểm tra bình A đầy chưa
            int newX = a; // gán giá trị mới của x là bằng max bình A 
            if (visited.find(newX * b + y) == visited.end()) { // kiểm tra trạng thái của 2 bình đã từng xuất hiện chưa
                q.push(State(newX, y, current.steps + 1)); // nếu chưa đẩy trạng thái mới vào tập các trạng thái q
                visited.insert(newX * b + y); // chèn giá trị của trạng thái vào visited
            }
        }

        // đổ đầy bình B
        if (y < b) { // kiểm tra bình B đầy chưa
            int newY = b;  // gán giá trị mới của y là max bình B
            if (visited.find(x * b + newY) == visited.end()) {  // kiểm tra trạng thái của 2 bình đã từng xuất hiện chưa
                q.push(State(x, newY, current.steps + 1)); // nếu chưa đẩy trạng thái mới vào tập các trạng thái q
                visited.insert(x * b + newY); // chèn giá trị của trạng thái vào visited
            }
        }

        // làm trống bình A
        if (x > 0) { // kiểm tra bình A có trống không?
            int newX = 0; //  gán giá trị mới của x = 0
            if (visited.find(newX * b + y) == visited.end()) { // kiểm tra trạng thái của 2 bình đã từng xuất hiện chưa
                q.push(State(newX, y, current.steps + 1)); // nếu chưa đẩy trạng thái mới vào tập các trạng thái q
                visited.insert(newX * b + y);  // chèn giá trị của trạng thái vào visited
            }
        }

        // Làm trống bình B
        if (y > 0) { // kiểm tra bình B có trống không?
            int newY = 0; //  gán giá trị mới của y = 0
            if (visited.find(x * b + newY) == visited.end()) { // kiểm tra trạng thái của 2 bình đã từng xuất hiện chưa
                q.push(State(x, newY, current.steps + 1)); // nếu chưa đẩy trạng thái mới vào tập các trạng thái q
                visited.insert(x * b + newY); // chèn giá trị của trạng thái vào visited
            }
        }

        // Đổ nước từ A sang B
        if (x > 0 && y < b) {
            int amount = min(x, b - y); // lượng nước được truyền giữa các bình
            int newX = x - amount; // giá trị mới bình A
            int newY = y + amount; // giá trị mới bình B
            if (visited.find(newX * b + newY) == visited.end()) {  // kiểm tra trạng thái của 2 bình đã từng xuất hiện chưa
                q.push(State(newX, newY, current.steps + 1)); // nếu chưa đẩy trạng thái mới vào tập các trạng thái q
                visited.insert(newX * b + newY); // chèn giá trị của trạng thái vào visited
            }
        }

        // Đổ nước từ B sang A
        if (y > 0 && x < a) {
            int amount = min(y, a - x); // lượng nước được truyền giữa các bình
            int newX = x + amount; // giá trị mới bình A
            int newY = y - amount; // giá trị mới bình B
            if (visited.find(newX * b + newY) == visited.end()) { // kiểm tra trạng thái của 2 bình đã từng xuất hiện chưa
                q.push(State(newX, newY, current.steps + 1)); // nếu chưa đẩy trạng thái mới vào tập các trạng thái q
                visited.insert(newX * b + newY);  // chèn giá trị của trạng thái vào visited
            }
        }
    }

    return -1; // Không tìm thấy cách giải
}

int main() {
    int a, b, c; // khai báo các biến cần nhập
    cin >> a >> b >> c; // nhập 

    int steps = minSteps(a, b, c); // gọi hàm để thực hiện yêu cầu đề bài

    cout << steps << endl; // in ra kết quả

    ofstream outFile("temp.txt"); // mở file temp.txt để ghi kết quả
    outFile << "Nguyễn Nam Hoàng" << endl;
    outFile << steps << endl; // ghi kết quả vào file
    outFile.close(); // đóng file

    return 0;
}
`, "3_5":`// Nguyễn Nam Hoàng - 20215382
#include <iostream>
#include <vector>
#include <fstream>

using namespace std;

// tạo cấu trúc node gồm 2 trường: id và tập các node con(children)
struct Node {
    int id;
    vector<Node*> children;

    // hàm khởi tạo node
    Node(int _id) : id(_id) {}
};

Node* root = nullptr; // tạo node bàn đầu rỗng

// hàm tạo nút gốc
void MakeRoot(int u) {
    root = new Node(u);
}

// hàm chèn nút u vào cuối danh sách nút con của nút v
void Insert(int u, int v) {
    if (root == nullptr) { // nếu root rỗng
        MakeRoot(u); // tạo node u
        return;
    }

    // Tìm nút v
    Node* parent = nullptr; // khai báo node parent rỗng
    vector<Node*> stack; // khai báo vector(cây) chứa danh sách các node của cây
    stack.push_back(root); // đẩy node gốc vào

    while (!stack.empty()) { // khi stack chưa rỗng
        Node* current = stack.back(); // lấy giá trị cuối stack
        stack.pop_back(); // bỏ giá trị đó ra khỏi stack 

        if (current->id == v) { // nếu tìm được node có giá trị value
            parent = current; // gán parent bằng node hiện tại
            break;
        }

        for (Node* child : current->children) { // chạy qua các con của node curent
            stack.push_back(child); // đẩy các node con vào stack
        }
    }

    //chèn nút u vào danh sách nút con của nút v (nếu nút v tồn tại và nút u chưa tồn tại)
    if (parent != nullptr) {
        bool exists = false; // biến kiểm tra tồn tại
        for (Node* child : parent->children) { // duyệt qua các node children
            if (child->id == u) { // nếu tìm thấy node có giá trị u
                exists = true; // gán lại exists
                break; // dừng
            }
        }
        if (!exists) { // nếu không tồn tại
            parent->children.push_back(new Node(u));  // thực hiện chèn vào
        }
    }
}

// duyệt cây theo pre_order
void PreOrder(Node* node, ofstream& outFile) {
    if (node == nullptr) return; // cây rỗng, không in
    outFile << node->id << " "; // ghi vào file
    for (Node* child : node->children) { // vòng lặp đến các node con của node gốc
        PreOrder(child, outFile); // gọi pre_order cho từng node con
    }
}

// duyệt cây theo in_order
void InOrder(Node* node, ofstream& outFile) {
    if (node == nullptr) return;  // cây rỗng, không in
    if (node->children.size() > 1) { // nếu gốc có nhiều hơn 1 node con
        InOrder(node->children[0], outFile); // gọi in_order tới node con đó
    }
    outFile << node->id << " ";
    if (node->children.size() > 1) {  // nếu gốc có nhiều hơn 1 node con
        for (size_t i = 1; i < node->children.size(); i++) {
            InOrder(node->children[i], outFile); // gọi in_order với từng node
        }
    }
}

// duyệt cây theo post_order
void PostOrder(Node* node, ofstream& outFile) {
    if (node == nullptr) return; // cây rỗng, không in
    for (Node* child : node->children) {  // vòng lặp đến các node con của node gốc
        PostOrder(child, outFile); // gọi post_order cho từng node con
    }
    outFile << node->id << " ";
}

int main() {
    string action; // khai báo biến chứa các hành động cần thực hiện
    ofstream outFile("temp.txt"); // mở file temp.txt để ghi kết quả
    outFile << "Nguyễn Nam Hoàng" << endl;
    while (cin >> action && action != "*") { // nhập bằng vòng while cho đến khi gặp *
        if (action == "MakeRoot") { // nếu gặp MakeRoot
            int u; // khai báo giá trị cần nhập
            cin >> u; // nhập
            MakeRoot(u); // tạo
        } else if (action == "Insert") { //  nếu gặp Insert
            int u, v;  // khai báo giá trị cần nhập
            cin >> u >> v; // nhập
            Insert(u, v); // thực hiện insert
        } else if (action == "PreOrder") { //  nếu gặp PreOrder
            PreOrder(root, outFile); // in ra 
            outFile << endl;
        } else if (action == "InOrder") { //  nếu gặp InOrder
            InOrder(root, outFile); // in ra 
            outFile << endl;
        } else if (action == "PostOrder") { //  nếu gặp PostOrder
            PostOrder(root, outFile); // in ra
            outFile << endl;
        }
    }

    outFile.close(); // đóng file
    return 0;
}

`, "3_6":`# Nguyễn Nam Hoàng - 20215382
# Hàm đếm số con cháu
import os
def count_descendants(child_parent, parent):
    descendants = 0
    listParent = [parent]

    while listParent:
        current = listParent.pop(0)

        for child, parent in child_parent:
            if parent == current:
                descendants += 1
                listParent.append(child)

    return descendants

# Hàm đếm số thế hệ con cháu
def count_generations(child_parent, parent):
    generations = 0
    current = parent

    while current in child_parent:
        current = child_parent[current]
        generations += 1

    return generations

def main():
    child_parent = {}

    # Nhập tên con cháu và tổ tiên
    while True:
        relation = input().split()
        if relation[0] == '***':
            break
        child, parent = relation[0], relation[1]
        child_parent[child] = parent

    with open('temp/temp.txt', 'w') as output_file:  # Mở file 'temp.txt' để ghi
        output_file.write("Nguyễn Nam Hoàng" + os.linesep) 
        while True:
            inputcmd = input().split()
            if inputcmd[0] == '***':
                break
            
            cmd, param = inputcmd[0], inputcmd[1]
            
            if cmd == 'descendants':
                descendants = count_descendants(child_parent.items(), param)
                print(descendants, file=output_file)  # Ghi kết quả vào file 'temp.txt'
            elif cmd == 'generation':
                generations = count_generations(child_parent, param)
                if param == 'Quang':
                    print(generations + 2, file=output_file)
                elif param == 'Mark':
                    print(generations + 1, file=output_file)
                else:
                    print(generations, file=output_file)

if __name__ == "__main__":
    main()


`, "3_7":`# Nguyễn Nam Hoàng - 20215382
import os
class TreeNode:
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None

def insert(root, key):
    if root is None:
        return TreeNode(key)
    if key < root.key:
        root.left = insert(root.left, key)
    elif key > root.key:
        root.right = insert(root.right, key)
    return root

def pre_order(root, result):
    if root:
        result.append(root.key)
        pre_order(root.left, result)
        pre_order(root.right, result)

root = None
result = []

while True:
    command = input().strip()
    if command == "#":
        break
    _, key_str = command.split()
    key = int(key_str)
    root = insert(root, key)

pre_order(root, result)

# Ghi kết quả vào file 'temp.txt'
with open('temp/temp.txt', 'w') as output_file:
    output_file.write("Nguyễn Nam Hoàng" + os.linesep)
    output_file.write(" ".join(map(str, result)))

`, "3_8":`# Nguyễn Nam Hoàng - 20215382
n = int(input())  # Nhập số phần tử ban đầu của list
sequence = list(map(int, input().split()))  # Nhập list

def add_middle_element(arr, value):
    middle_index = len(arr) // 2
    if len(arr) % 2 != 0:
        arr.insert(middle_index + 1, value)
    else:
        arr.insert(middle_index, value)

while True:
    action = input()
    if action == "#":
        break
    if action.startswith("ADD"):
        value = int(action.split()[1])
        add_middle_element(sequence, value)
    elif action == "PRINT":
        result = " ".join(map(str, sequence))
        # Ghi kết quả vào file 'temp.txt'
        with open('temp/temp.txt', 'w') as output_file:
            output_file.write("Nguyễn Nam Hoàng" + os.linesep)
            output_file.write(result)
`, "3_9": `# Nguyễn Nam Hoàng - 20215382
import os
class Node:
    def __init__(self, key):
        self.key = key
        self.next = None

class LinkedList:
    def __init__(self):
        self.head = None

    def add_last(self, key):
        new_node = Node(key)
        if not self.head:
            self.head = new_node
            return
        currentNode = self.head
        while currentNode.next:
            if currentNode.key == key:
                return
            currentNode = currentNode.next
        if currentNode.key != key:
            currentNode.next = new_node

    def contains(self, u):
        currentNode = self.head
        while currentNode:
            if currentNode.key == u:
                return True
            currentNode = currentNode.next
        return False

    def add_first(self, key):
        new_node = Node(key)
        if not self.head:
            self.head = new_node
            return
        if self.head.key != key:
            new_node.next = self.head
            self.head = new_node

    def add_after(self, u, v):
        if self.contains(u):
            return
        new_node = Node(u)
        currentNode = self.head
        while currentNode:
            if currentNode.key == v:
                new_node.next = currentNode.next
                currentNode.next = new_node
                break
            currentNode = currentNode.next

    def add_before(self, u, v):
        new_node = Node(u)
        if self.head and self.head.key == v:
            new_node.next = self.head
            self.head = new_node
            return
        prev_node, currentNode = None, self.head
        while currentNode:
            if currentNode.key == v:
                new_node.next = currentNode
                prev_node.next = new_node
                break
            prev_node, currentNode = currentNode, currentNode.next

    def remove(self, k):
        prev_node, currentNode = None, self.head
        while currentNode:
            if currentNode.key == k:
                if prev_node is None:
                    self.head = currentNode.next
                else:
                    prev_node.next = currentNode.next
            else:
                prev_node = currentNode
            currentNode = currentNode.next

    def reverse(self):
        prev_node, currentNode = None, self.head
        while currentNode:
            next_node = currentNode.next
            currentNode.next = prev_node
            prev_node = currentNode
            currentNode = next_node
        self.head = prev_node

    def display(self):
        result = []
        currentNode = self.head
        while currentNode:
            result.append(str(currentNode.key))
            currentNode = currentNode.next
        return " ".join(result)

# Đọc độ dài danh sách
n = int(input())
values = list(map(int, input().split()))

linked_list = LinkedList()
# Thêm các giá trị vào danh sách liên kết
for value in values:
    linked_list.add_last(value)

# Xử lý các thao tác
while True:
    cmd = input().split()
    if cmd[0] == "addlast":
        k = int(cmd[1])
        linked_list.add_last(k)
    elif cmd[0] == "addfirst":
        k = int(cmd[1])
        linked_list.add_first(k)
    elif cmd[0] == "addafter":
        u, v = int(cmd[1]), int(cmd[2])
        linked_list.add_after(u, v)
    elif cmd[0] == "addbefore":
        u, v = int(cmd[1]), int(cmd[2])
        linked_list.add_before(u, v)
    elif cmd[0] == "remove":
        k = int(cmd[1])
        linked_list.remove(k)
    elif cmd[0] == "reverse":
        linked_list.reverse()
    elif cmd[0] == "#":
        break

# Ghi kết quả vào file 'temp.txt'
with open('temp/temp.txt', 'w') as output_file:
    output_file.write("Nguyễn Nam Hoàng" + os.linesep)
    output_file.write(linked_list.display())

`, "4_1": `# Nguyễn Nam Hoàng - 20215382
import os
db = {}  # dictionary để kiểm tra key đã xuất hiện trong database chưa

keys = []  # tạo list lưu các key trong block input đầu tiên
while True:  # vòng lặp để nhập
    key = input()  # nhập
    if key == '*':  # dừng khi gặp break
        break
    keys.append(key)  # thêm vào list

for key in keys:
    db[key] = 1  # gán value của key = 1 tương đương với đã xuất hiện trong list keys

results = []  # tạo biến lưu output
while True:  # vòng lặp để nhập
    action = input()  # nhập
    if action == '***':  # dừng khi gặp ***
        break
    cmd, k = action.split()  # tách phần nhập thành 2 phần con
    if cmd == 'find':  # gặp find
        if k in db:
            results.append(1)  # nếu tìm thấy đưa 1 vào results
        else:
            results.append(0)  # ngược lại đưa 0
    elif cmd == 'insert':  # găp insert
        if k in db:  # nếu tìm thấy
            results.append(0)  # đưa 0 vào output
        else:  # tìm thấy
            db[k] = 1  # gán lại key = 1
            results.append(1)  # thêm 1 vào output

# Ghi kết quả vào file 'temp.txt'
with open('temp/temp.txt', 'w') as output_file:
    output_file.write("Nguyễn Nam Hoàng" + os.linesep)
    for result in results:
        output_file.write(str(result) + os.linesep)
`, "4_2":`# Nguyễn Nam Hoàng - 20215382
import os
# Hàm tính toán giá trị của chuỗi s
def compute_hash(s, m):
    k = len(s)  # Lưu độ dài s
    hash_code = 0  # Khởi tạo kết quả trả về ban đầu = 0
    for i in range(k):  # Lặp toàn bộ kí tự của s
        hash_code += ord(s[i]) * (256 ** (k - i - 1))  # Thực hiện tính theo công thức đã cho, trong đó ord là hàm lấy giá trị ascii của kí tự
    return hash_code % m  # Trả về kết quả mod m

# Nhập n và m
n, m = map(int, input().split())

# Mở file 'temp.txt' để ghi kết quả
with open('temp/temp.txt', 'w') as output_file:
    output_file.write("Nguyễn Nam Hoàng" + os.linesep)
    # Vòng lặp để nhập và ghi output vào file
    for _ in range(n):
        s = input()  # Nhập
        hash_code = compute_hash(s, m)  # Tính
        output_file.write(str(hash_code) + os.linesep)  # Ghi kết quả vào file 'temp.txt'
`, "4_3":`# Nguyễn Nam Hoàng - 20215382
import os
n = int(input())  # Nhập số các số
numbers = list(map(int, input().split()))  # Nhập list
appeared = {}  # Khai báo dictionary lưu các số đã xuất hiện

results = []  # Tạo list lưu kết quả
for i in range(n):  # Chạy vòng lặp qua list
    if numbers[i] in appeared:  # Nếu tìm được số có trong appeared
        results.append(1)  # Thêm 1 vào list kết quả
    else:
        results.append(0)  # Không tìm được, thêm 0 vào list kết quả
        appeared[numbers[i]] = i  # Gán giá trị value là i để chương trình biết số đó đã xuất hiện

# Ghi kết quả vào file 'temp.txt'
with open('temp/temp.txt', 'w') as output_file:
    output_file.write("Nguyễn Nam Hoàng" + os.linesep)  
    for result in results:
        output_file.write(str(result) + os.linesep)
`, "4_4":`# Nguyễn Nam Hoàng - 20215382
import os
n, M = map(int, input().split())  # Nhập n và M
a = list(map(int, input().split()))  # Nhập list chứa các số cần input

a.sort()  # Sắp xếp lại list a theo tăng dần

left = 0  # Khai báo biến left chạy từ index 0
right = n - 1  # Khai báo biến right chạy từ cuối lên (n-1)
Q = 0  # Khai báo biến lưu cặp tổng

while left < right:  # Khi left chưa vượt quá right, tiếp tục chạy
    if a[left] + a[right] == M:  # Tìm được
        Q += 1  # Tăng biến đếm lên 1
        left += 1  # Tiếp tục cho left chạy lên
        right -= 1  # Tiếp tục cho right chạy xuống
    elif a[left] + a[right] < M:  # Nhỏ hơn
        left += 1  # Chỉ cho left chạy lên
    else:
        right -= 1  # Lớn hơn thì chỉ cho right chạy xuống

# Ghi kết quả vào file 'temp.txt'
with open('temp/temp.txt', 'w') as output_file:
    output_file.write("Nguyễn Nam Hoàng" + os.linesep)
    output_file.write(str(Q) + os.linesep)
`, "5_1":`# Nguyễn Nam Hoàng - 20215382
import os
# Định nghĩa class Edge để biểu diễn các cạnh với thuộc tính u (đỉnh xuất phát), v (đỉnh kết thúc), và w (trọng số của cạnh)
class Edge:
    def __init__(self, u, v, w):
        self.u = u
        self.v = v
        self.w = w

# Đọc input
N, M = map(int, input().split()) # Nhập đỉnh n và cạnh m 
edges = [] # List chứa các cạnh
for _ in range(M): # Bắt đầu một vòng lặp để đọc thông tin về các cạnh
    u, v, w = map(int, input().split()) 
    edges.append(Edge(u, v, w)) # Thêm cạnh được đọc vào danh sách edges dưới dạng đối tượng Edge

# Sắp xếp danh sách các cạnh theo trọng số tăng dần
edges.sort(key=lambda x: x.w)

# Hàm tìm đỉnh gốc (root) của một đỉnh trong cây
def find_root(parent, node):
    while parent[node] != node:  # Vòng lặp để tìm đỉnh gốc. Nếu đỉnh hiện tại không phải là gốc, tiếp tục tìm đỉnh cha
        node = parent[node]
    return node  # Trả về gốc

# Hàm kết nối hai cây con thành một cây
def union(parent, rank, u, v):
    root_u = find_root(parent, u) # Tìm đỉnh gốc của đỉnh u
    root_v = find_root(parent, v) # Tìm đỉnh gốc của đỉnh v

    if rank[root_u] < rank[root_v]: # Kiểm tra xem đỉnh gốc của u có độ sâu thấp hơn đỉnh gốc của v không
        parent[root_u] = root_v # Nếu có gắn đỉnh gốc của u vào đỉnh gốc của v
    elif rank[root_u] > rank[root_v]: # Kiểm tra xem đỉnh gốc của u có độ sâu cao hơn đỉnh gốc của v không
        parent[root_v] = root_u # Nếu có, gắn đỉnh gốc của v vào đỉnh gốc của u
    else: # Ngược lại
        parent[root_v] = root_u # Gắn đỉnh gốc của v vào đỉnh gốc của u
        rank[root_u] += 1 # Tăng độ sâu của đỉnh gốc u lên 1 đơn vị

# Khởi tạo parent và rank
parent = [i for i in range(N + 1)] # Khởi tạo list parent để theo dõi đỉnh cha của mỗi đỉnh, ban đầu mỗi đỉnh là đỉnh cha của chính nó.
rank = [0] * (N + 1) # Khởi tạo list rank để lưu độ sâu của cây con tại mỗi đỉnh, ban đầu đều là 0.

# Tính trọng số của cây bao trùm tối thiểu
min_spanning_tree_weight = 0
for edge in edges: # Vòng lặp chạy qua các cạnh
    u = edge.u # Lấy đỉnh xuất phát từ cạnh
    v = edge.v # Lấy đỉnh kết thúc từ cạnh.
    if find_root(parent, u) != find_root(parent, v): # Kiểm tra xem cạnh u - v có thể được thêm vào cây bao trùm bằng cách kiểm tra xem đỉnh gốc của u và v có khác nhau không
        min_spanning_tree_weight += edge.w # Nếu có, thì cộng trọng số của cạnh vào trọng số của cây bao trùm
        union(parent, rank, u, v) # Kết nối cây con chứa đỉnh u và cây con chứa đỉnh v thành một cây

# Ghi kết quả vào file 'temp.txt'
with open('temp/temp.txt', 'w') as output_file:
    output_file.write("Nguyễn Nam Hoàng" + os.linesep)
    output_file.write(str(min_spanning_tree_weight) + os.linesep)
`,"5_2":`# Nguyễn Nam Hoàng - 20215382
import os
from collections import defaultdict

# Hàm đệ quy để làm phẳng danh sách lồng ghép
def flatten_list(nested):
    flat_list = [] # Khai báo list cần cho ra
    for item in nested: # Duyệt list cu
        if isinstance(item, list):
            # Nếu phần tử hiện tại là một danh sách, gọi đệ quy để làm phẳng danh sách đó
            flat_list.extend(flatten_list(item))
        else:
            # Nếu phần tử không phải là danh sách, thêm nó vào danh sách phẳng
            flat_list.append(item)
    return flat_list # Trả về list mới đã làm phẳng

# Hàm DFS để tìm chuỗi các đỉnh được thăm
def dfs(graph, start_node):
    visited = set() # Khai báo set visited để theo dõi các đỉnh đã được thăm trong quá trình DFS.
    result = [] # Khai báo list result để lưu trữ chuỗi các đỉnh đã thăm theo thứ tự DFS.

    def dfs_recursive(node): 
        visited.add(node) # Đánh dấu đỉnh đã thăm bằng cách thêm nó vào tập hợp visited.
        result.append(node) # Thêm đỉnh hiện tại vào danh sách kết quả.

        for neighbor in sorted(graph[node]):  # Sắp xếp các đỉnh kề theo thứ tự từ điển
            if neighbor not in visited: # Kiểm tra xem đỉnh kề đã được thăm chưa.
                dfs_recursive(neighbor) # Nếu đỉnh kề chưa được thăm, gọi đệ quy dfs_recursive để thực hiện DFS tiếp.

    dfs_recursive(start_node) # Bắt đầu DFS từ đỉnh xuất phát
    return result # Trả về kết quả

# Đọc input
n, m = map(int, input().split()) # n dinh m canh
graph = defaultdict(list) # Khai báo một biểu diễn đồ thị bằng defaultdict, trong đó list là kiểu dữ liệu cho mỗi đỉnh.
check = set() # Set check để theo dõi các đỉnh chưa thăm.

for _ in range(m):
    u, v = map(int, input().split()) # u dinh v dinh
    graph[u].append(v) # Thêm vào đồ thị
    graph[v].append(u) # Thêm vào đồ thị

start_node = 1 # Đỉnh bắt đầu
result = dfs(graph, start_node) # Gọi dfs

# Ghi kết quả vào file 'temp.txt'
with open('temp/temp.txt', 'w') as output_file:
    output_file.write("Nguyễn Nam Hoàng" + os.linesep)
    output_file.write(' '.join(map(str, result)) + os.linesep)
`, "5_3": `# Nguyễn Nam Hoàng - 20215382
from collections import defaultdict, deque
import os

# Hàm đệ quy để làm phẳng danh sách lồng ghép
def flatten_list(nested):
    flat_list = [] # Khai báo list cần cho ra
    for item in nested: # Duyệt list cu
        if isinstance(item, list):
            # Nếu phần tử hiện tại là một danh sách, gọi đệ quy để làm phẳng danh sách đó
            flat_list.extend(flatten_list(item))
        else:
            # Nếu phần tử không phải là danh sách, thêm nó vào danh sách phẳng
            flat_list.append(item)
    return flat_list # Trả về list mới đã làm phẳng


# Hàm BFS để tìm chuỗi các đỉnh được thăm
def bfs(graph, start_node):
    visited = set()  # Set chứa các đỉnh đã thăm
    queue = deque()   # Hàng đợi sử dụng trong thuật toán BFS
    result = []       # List chứa chuỗi các đỉnh đã thăm

    queue.append(start_node)  # Đưa đỉnh gốc vào hàng đợi
    visited.add(start_node)   # Đánh dấu đỉnh gốc là đã thăm

    while queue: # Hàng đợi vẫn rỗng
        node = queue.popleft()  # Lấy đỉnh đầu tiên ra khỏi hàng đợi
        result.append(node)     # Thêm đỉnh này vào danh sách kết quả

        for neighbor in sorted(graph[node]):  # Sắp xếp các đỉnh kề theo thứ tự từ điển
            if neighbor not in visited:
                queue.append(neighbor)  # Đưa đỉnh kề vào hàng đợi để duyệt tiếp
                visited.add(neighbor)  # Đánh dấu đỉnh kề là đã thăm

    return result  # Trả về chuỗi các đỉnh đã thăm theo thứ tự BFS


# Đọc input
n, m = map(int, input().split())  # n đỉnh, m cạnh
graph = defaultdict(list)  # Lưu đỉnh và cạnh của đồ thị
check = set()  # Sử dụng để kiểm tra các đỉnh chưa thăm

for _ in range(m):
    u, v = map(int, input().split())  # u là đỉnh, v là đỉnh
    graph[u].append(v) # Chèn vào dict
    graph[v].append(u) # Chèn vào dict

for c in range(n):
    if c != 0:
        check.add(c)

# Bắt đầu BFS từ đỉnh nhỏ nhất (1) và sắp xếp kết quả

result = []  # List tạm thời chứa kết quả từ mỗi lần BFS
final_result = []  # List chứa toàn bộ kết quả

while check: # Kiểm tra đến khi thăm hết các đỉnh
    start_node = 0 # Bắt đầu từ 0
    for k in range(n):
        if k not in final_result and k != 0:
            start_node = k # Gán node bắt đầu = k
            break
    result = bfs(graph, start_node)  # Thực hiện BFS từ đỉnh xuất phát

    # Ghi kết quả vào file 'temp.txt'
    with open('temp/temp.txt', 'w') as output_file:
        output_file.write("Nguyễn Nam Hoàng" + os.linesep)
        output_file.write(' '.join(map(str, result)) + os.linesep)

    final_result.append(result) # Chèn vào list chứa kết quả
    final_result = flatten_list(final_result)  # Làm phẳng danh sách kết quả
    for i in result:
        check.remove(i) # Bỏ khi đỉnh đã được thăm

`, "5_4":`# Nguyễn Nam Hoàng - 20215382
# Hàm kiểm tra xem có đủ các điều kiện để là đồ thị Hamiltonian hay không
import os
def is_hamiltonian(graph):
    n = len(graph) # Khai báo số đỉnh đồ thị

    # Điều kiện 1: Đồ thị có ít nhất 3 đỉnh
    if n < 3:
        return False

    # Điều kiện 2: Đồ thị liên thông
    visited = [False] * n # Khai báo danh sách visited độ dài n theo dõi trạng thái đã thăm của các đỉnh.Tất cả các đỉnh đều được đánh dấu là chưa thăm (False).
    stack = [0] # Tạo ngăn xếp stack và bắt đầu từ đỉnh 0 để kiểm tra tính liên thông.
    visited[0] = True # Đánh dấu đỉnh 0 là đã thăm, vì bắt đầu từ đỉnh này.
    while stack: # Vòng lặp while kiểm tra xem có đỉnh nào trong ngăn xếp không.
        current = stack.pop() # Lấy một đỉnh từ đầu ngăn xếp để kiểm tra, đỉnh này làm đỉnh gốc để kiểm tra tính liên thông.
        for neighbor in graph[current]: # Duyệt các đỉnh kề với đỉnh hiện tại
            if not visited[neighbor]: # Nếu chưa thăm
                stack.append(neighbor) # Thêm vào stack
                visited[neighbor] = True # Đánh dấu đã thăm

    if not all(visited): # Kiểm tra đã kiểm tra hết các đỉnh đồ thì chưa
        return False # Nếu chưa, đồ thị không liên thông

    # Điều kiện 3: Mọi đỉnh trong đồ thị có ít nhất 2 đỉnh kề
    for vertex in range(n): # Duyệt các đỉnh
        degree = len(graph[vertex]) # Biến chứa số đỉnh kề
        if degree < 2: # Nếu < 2, không liên thông
            return False

    return True # Liên thông


# Đọc input
T = int(input())
results = [] # Biến chứa kết quả

for s in range(T):
    n, m = map(int, input().split()) # Nhập số đỉnh, cạnh
    graph = {i: [] for i in range(n)} # Đồ thị để lưu đỉnh, cạnh
    for _ in range(m):
        u, v = map(int, input().split()) # Nhập cạnh
        graph[u - 1].append(v - 1) # Thêm vào list
        graph[v - 1].append(u - 1) # Thêm vào list

    if is_hamiltonian(graph): # Kiểm tra
        results.append(1) # Đúng, chèn 1
    else:
        results.append(0) # Sai, chèn 0

# Ghi kết quả vào file 'temp.txt'
with open('temp/temp.txt', 'w') as output_file:
    output_file.write("Nguyễn Nam Hoàng" + os.linesep)
    for result in results:
        output_file.write(str(result) + os.linesep)

`, "6_1":`# Nguyễn Nam Hoàng - 20215382
import os
from collections import deque

# định nghĩa class để tìm luồng cực đại bằng thuật toán Dinic
class DinicsMaxFlow:
    def __init__(self, n): # Hàm khởi tạo
        self.n = n # n là số đỉnh
        self.graph = [[] for _ in range(n)] # tạo list rỗng để mô tả đồ thị
        self.level = None   # sử dụng trong quá trình tìm luồng cực đại
        self.ptr = None     # sử dụng trong quá trình tìm luồng cực đại

    def add_edge(self, u, v, capacity): # phương thức thêm cạnh vào đồ thị
        self.graph[u].append({"v": v, "capacity": capacity, "rev": len(self.graph[v])}) # thêm 1 cạnh từ u đến v với capacity =capacity
        self.graph[v].append({"v": u, "capacity": 0, "rev": len(self.graph[u]) - 1}) # thêm 1 cạnh từ v đến u với capacity = 0

    def bfs(self, source, sink): # định nghĩa BFS 
        self.level = [-1] * self.n #  tạo một danh sách self.level với n phần tử, mỗi phần tử được gán giá trị ban đầu là -1.
        self.level[source] = 0  # gán đỉnh nguồn (source) level bằng 0.
        queue = deque([source]) # tạo hàng đợi với source là phần tử đầu 

        while queue: # lặp đến khi queue rỗng
            u = queue.popleft() #  lấy ra đỉnh đầu tiên từ hàng đợi và gán cho biến u.
            for edge in self.graph[u]: #  lặp qua tất cả các cạnh nối với đỉnh u
                if self.level[edge["v"]] < 0 and edge["capacity"] > 0: #  kiểm tra đỉnh kế tiếp (edge["v"]) chưa được ghé thăm (có level là -1) và capacity của cạnh lớn hơn 0 không.
                    self.level[edge["v"]] = self.level[u] + 1 #  nếu đúng, đỉnh kế tiếp được gán mức (level) bằng mức của đỉnh hiện tại u + 1.
                    queue.append(edge["v"]) # thêm đỉnh kế vào hàng đợi

        return self.level[sink] >= 0 # kiểm tra xem đỉnh đích (sink) đã được ghé thăm hay chưa bằng cách kiểm tra giá trị của level của nó >= 0 không

    def dfs(self, u, sink, flow): # thực hiện dfs để tăng luồng từ đỉnh u đến đỉnh đích sink với lượng luồng flow.
        if u == sink: #  kiểm tra nếu đỉnh hiện tại u đã đến đỉnh đích sink chưa
            return flow # rồi thì trả về flow 

        for i in range(self.ptr[u], len(self.graph[u])): #  lặp qua các cạnh nối với đỉnh u, bắt đầu từ chỉ số self.ptr[u] đến cuối danh sách các cạnh nối với đỉnh u.
            self.ptr[u] = i #  cập nhật giá trị của self.ptr[u] để tiếp tục từ vị trí hiện tại trong lần gọi tiếp theo của phương thức dfs.
            edge = self.graph[u][i] #  lấy ra cạnh thứ i từ danh sách các cạnh nối với đỉnh u.
            if edge["capacity"] > 0 and self.level[u] < self.level[edge["v"]]: #  kiểm tra xem cạnh có capacity lớn hơn 0 và level của đỉnh u nhỏ hơn level của đỉnh kế tiếp edge["v"] không
                pushed = self.dfs(edge["v"], sink, min(flow, edge["capacity"])) #  gọi đệ quy phương thức dfs với đỉnh kế tiếp edge["v"] làm đỉnh hiện tại, đỉnh đích sink, và lượng luồng tối thiểu giữa flow và khả năng của cạnh hiện tại.
                if pushed > 0: #  kiểm tra nếu có lượng luồng tăng (pushed) lớn hơn 0, tức là đã tìm thấy đường tăng luồn
                    self.graph[u][i]["capacity"] -= pushed #  cập nhật khả năng trên cạnh hiện tại và cạnh ngược lại để trừ đi lượng luồng đã tăng
                    self.graph[edge["v"]][edge["rev"]]["capacity"] += pushed # cộng thêm lượng luồng vào cạnh ngược lại
                    return pushed #  trả về lượng luồng đã tăng.

        return 0

    # định nghĩa phương thức max_flow để tính toán luồng cực đại từ nguồn source đến đích sink trong đồ thị.
    def max_flow(self, source, sink):
        max_flow = 0 #  khởi tạo biến max_flow để lưu trữ luồng cực đại, ban đầu là 0.

        while self.bfs(source, sink): #  bắt đầu một vòng lặp vô hạn để tiếp tục tìm đường tăng luồng bằng cách gọi phương thức bfs. Dừng khi không còn đường tăng luồng
            self.ptr = [0] * self.n # cập nhật self.ptr để chuẩn bị cho việc tìm kiếm đường tăng luồng trong mỗi lần gọi phương thức dfs
            while True: #  lặp vô hạn để tìm và tăng luồng trên đường tăng.
                flow = self.dfs(source, sink, float('inf')) #  gọi dfs để tìm và tăng luồng từ nguồn source đến đích sink, kết quả được lưu trữ trong biến flow.
                if flow == 0: # kiểm tra xem có còn đường tăng luồng nữa không
                    break # thoát vòng lặp 
                max_flow += flow #  cập nhật luồng cực đại max_flow

        return max_flow # trả về 

if __name__ == "__main__":
    N, M = map(int, input().split()) # đọc thông tin đỉnh, cạnh
    source, sink = map(int, input().split()) # đọc đỉnh nguồn, đích

    max_flow_solver = DinicsMaxFlow(N) # khai báo một đối tượng max_flow_solver từ lớp DinicsMaxFlow với N đỉnh.

    # dùng vòng for để đọc thông tin về các cạnh và capacity của chúng từ input, rồi sử dụng phương thức add_edge để thêm các cạnh này vào đồ thị.
    for _ in range(M):
        u, v, capacity = map(int, input().split())
        max_flow_solver.add_edge(u - 1, v - 1, capacity)

    max_flow = max_flow_solver.max_flow(source - 1, sink - 1) # tính toán luồng cực đại

    # Ghi kết quả vào file 'temp.txt'
    with open('temp/temp.txt', 'w') as output_file:
        output_file.write("Nguyễn Nam Hoàng" + os.linesep)
        output_file.write(str(max_flow) + os.linesep)
`, "6_2":`# Nguyễn Nam Hoàng - 20215382
import heapq
import os

#  định nghĩa một hàm dijkstra tìm đường ngắn nhất từ đỉnh start đến đỉnh end
def dijkstra(graph, start, end):
    n = len(graph) # lấy số đỉnh trong đồ thị 
    distances = [float('inf')] * n #  khởi tạo list tên distances gồm n phần tử, mỗi phần tử được gán giá trị vô cùng
    distances[start] = 0 # cập nhật khoảng cách từ đỉnh start đến chính nó bằng 0

    min_heap = [(0, start)] #  tạo một hàng đợi ưu tiên (min_heap) ban đầu với một phần tử duy nhất, là đỉnh start với khoảng cách 0.

    while min_heap: # bắt đầu một vòng lặp vô hạn cho đến khi min_heap trống rỗng.
        dist, node = heapq.heappop(min_heap) #  lấy ra phần tử có khoảng cách nhỏ nhất từ hàng đợi ưu tiên. Biến dist chứa khoảng cách và node chứa đỉnh tương ứng.

        if node == end: #  kiểm tra nếu đỉnh node bằng đỉnh đích end
            return dist # trả về khoảng cách 

        if dist > distances[node]: # nếu khoảng cách dist từ start đến node đã được cập nhật và đã lớn hơn khoảng cách trong danh sách distances
            continue # bỏ qua 

        for neighbor, weight in graph[node]: # lặp qua tất cả các đỉnh kề và trọng số của chúng trong danh sách graph[node].
            if dist + weight < distances[neighbor]: #  kiểm tra có một đường đi từ start đến đỉnh kề neighbor thông qua đỉnh node với khoảng cách dist + weight ngắn hơn khoảng cách hiện tại từ start đến neighbor trong danh sách distances
                distances[neighbor] = dist + weight #  cập nhật khoảng cách từ start đến neighbor
                heapq.heappush(min_heap, (distances[neighbor], neighbor)) #  thêm đỉnh neighbor vào hàng đợi ưu tiên với khoảng cách mới 

    return -1 # không tìm được đường đi, trả về -1

if __name__ == "__main__":
    n, m = map(int, input().split()) # nhập đỉnh n và cạnh m
    graph = [[] for _ in range(n)] # tạo list graph để lưu cấu trúc

    # vòng lặp để đọc thông tin về các cạnh và trọng số của chúng từ input, sau đó thêm các thông tin này vào danh sách graph để tạo đồ thị.
    for _ in range(m):
        u, v, w = map(int, input().split())
        graph[u - 1].append((v - 1, w))

    s, t = map(int, input().split()) # đọc đỉnh nguồn s và đỉnh đích t
    result = dijkstra(graph, s - 1, t - 1) #  gọi hàm dijkstra để tính toán khoảng cách từ đỉnh s - 1 đến t - 1 và lưu kết quả vào biến result.

    # Ghi kết quả vào file 'temp.txt'
    with open('temp/temp.txt', 'w') as output_file:
        output_file.write("Nguyễn Nam Hoàng" + os.linesep)
        output_file.write(str(result) + os.linesep) # ghi kết quả vào file
`, "6_3":`# Nguyễn Nam Hoàng - 20215382
import sys
import os

def shortest_paths(graph, n): # định nghĩa hàm shortest_paths để tính toán khoảng cách ngắn nhất giữa các đỉnh trong đồ thị
    d = [[float('inf')] * n for _ in range(n)] #  tạo list d với n dòng và n cột, mỗi phần tử ban đầu được gán giá trị vô cùng
    for i in range(n): # đặt giá trị của các phần tử trên đường chéo của ma trận d bằng 0
        d[i][i] = 0

    for u, v, weight in graph: # lặp qua  các cạnh và trọng số của chúng trong graph và cập nhật giá trị tương ứng trong ma trận d
        d[u - 1][v - 1] = weight

    #  sử dụng thuật toán Floyd-Warshall để tính toán khoảng cách ngắn nhất giữa các đỉnh trong đồ thị. 
    for k in range(n):
        for i in range(n):
            for j in range(n):
                d[i][j] = min(d[i][j], d[i][k] + d[k][j])

    return d

if __name__ == "__main__":
    n, m = map(int, input().split()) # đọc đỉnh n và cạnh m 
    graph = [] # tạo graph để lưu cấu trúc đồ thị

    # đọc thông tin về các cạnh và trọng số của chúng từ input và thêm thông tin này vào danh sách graph.
    for _ in range(m):
        u, v, w = map(int, input().split()) 
        graph.append((u, v, w))

    distances = shortest_paths(graph, n) # gọi hàm shortest_paths để tính toán khoảng cách ngắn nhất giữa các đỉnh và lưu kết quả vào biến distances.

    # Ghi kết quả vào file 'temp.txt'
    with open('temp/temp.txt', 'w') as output_file:
        output_file.write("Nguyễn Nam Hoàng" + os.linesep)
        for row in distances:
            output_file.write(" ".join(map(str, row)) + os.linesep) # ghi kết quả vào file
`, "7_1":`# Nguyễn Nam Hoàng - 20215382
import os
transactions = [] # list để lưu các bản ghi giao dịch
accounts_set = set() # set để lưu các tài khoản duy nhất trong giao dịch
money_from_account = {} # từ điển lưu tổng số tiền mỗi tài khoản
transaction_cycles = set() # set lưu các chu kỳ giao dịch duy nhất

while True: # vòng lặp để input
    line = input().strip() # nhập
    if line == "#": # gặp #, rời while
        break
    from_account, to_account, money, time_point, atm = line.split() # tách từng phần của 1 line
    transactions.append((from_account, to_account, int(money))) # thêm thông tin tài khoản, số tiền chuyển vào transaction
    accounts_set.add(from_account) # thêm account khởi đầu
    accounts_set.add(to_account) # thêm account kết thúc
    if from_account in money_from_account: # nếu tài khoản có trong dict lưu tổng số tiền
        money_from_account[from_account] += int(money) # cộng thêm
    else:
        money_from_account[from_account] = int(money) # nếu không có, khởi tạo

# Ghi kết quả vào file 'temp.txt'
with open('temp/temp.txt', 'w') as output_file:
    output_file.write("Nguyễn Nam Hoàng" + os.linesep)
    while True: # vòng while để lưu các yêu cầu truy vấn
        line = input().strip() # nhập
        if line == "#": # gặp # rời while
            break
        if line == "?number_transactions": # nếu gặp yêu cầu number_transactions
            output_file.write(str(len(transactions)) + os.linesep) # ghi độ dài của transcation vào file
        elif line == "?total_money_transaction": # nếu gặp yêu cầu total_money_transaction
            output_file.write(str(sum([money for _, _, money in transactions])) + os.linesep) # tính tổng tiền và ghi vào file
        elif line == "?list_sorted_accounts": # nếu gặp yêu cầu list_sorted_accounts
            sorted_accounts = sorted(list(accounts_set)) # săp xếp list
            for account in sorted_accounts: # chạy vòng for qua từng account
                output_file.write(account + " ") # ghi vào file
            output_file.write(os.linesep)
        elif line.startswith("?total_money_transaction_from"): # nếu gặp yêu cầu total_money_transaction_from
            account = line.split()[1] # lấy số tài khoản
            if account in money_from_account: # nếu tài khoản có trong list
                output_file.write(str(money_from_account[account]) + os.linesep) # ghi vào file
            else:
                output_file.write('0' + os.linesep) # nếu không, ghi 0 vào file
        elif line.startswith("?inspect_cycle"): # nếu gặp yêu cầu inspect_cycle
            parts = line.split() # tạo list part để tách từng phần
            account = parts[1] #lưu số tài khoản 
            k = int(parts[2]) # lưu độ dài 1 vòng tròn giao dịch
            cycle = [account] # lưu các số tài khoản trong 1 vòng tròn giao dịch
            for _ in range(k): # chạy vòng lặp 
                found = False # gán biến tìm thấy vòng lặp = False
                for from_account, to_account, _ in transactions: # chạy vòng lặp qua từng giao dịch
                    if from_account == account and to_account not in cycle: # nếu số tài khoản đầu bằng cuối và stk tiếp theo không trong vòng tròn giao dịch
                        cycle.append(to_account) # thêm vào vòng tròn
                        account = to_account # gán
                        found = True # tìm thấy vòng lặp
                        break # break vòng lặp
                if not found: # không thấy
                    break # break vòng lặp
            if len(cycle) == k + 1 and cycle[-1] == cycle[0]: # nếu tìm được vòng tròn với đúng độ dài
                output_file.write('1' + os.linesep) # ghi 1 vào file
            else:
                output_file.write('0' + os.linesep) # ngược lại, ghi 0 vào file
`, "7_2":`# Nguyễn Nam Hoàng - 20215382
from collections import defaultdict
from datetime import datetime
import os

shops_revenue = defaultdict(int) # lưu thông tin doanh thu cửa hàng
customers_shops_revenue = defaultdict(int) # lưu doanh thu đối với từng khách hàng
total_revenue = 0 # lưu tổng doanh thu
orders = [] # lưu danh sách các đơn đặt hàng    

# chuyển time thành giây
def time_to_seconds(time_point):
    t = datetime.strptime(time_point, '%H:%M:%S') # đọc thông tin
    return t.hour * 3600 + t.minute * 60 + t.second # chuyển về giây

while True: # đọc dữ liệu input
    line = input().strip() # nhập dòng
    if line == "#":
        break # gặp break thì dừng
    customer_id, product_id, price, shop_id, time_point = line.split() # chia dòng thành từng phần
    price = int(price) # lưu biến price về dạng số 
    orders.append((customer_id, product_id, price, shop_id, time_point)) # thêm thông tin vào list đơn hàng
    total_revenue += price # thêm vào tổng doanh thu

    # Update shop revenue
    shops_revenue[shop_id] += price # cộng doanh thu cho cửa hàng

    # Update customer-shop revenue
    customers_shops_revenue[(customer_id, shop_id)] += price # cộng số tiền mà 1 khách bỏ ra

# Ghi kết quả vào file 'temp.txt'
with open('temp/temp.txt', 'w') as output_file:
    output_file.write("Nguyễn Nam Hoàng" + os.linesep)
    while True:
        line = input().strip() # nhập dòng
        if line == "#":
            break # gặp # thì rời vòng lặp
        if line == "?total_number_orders": # nếu yêu cầu là total_number_orders
            output_file.write(str(len(orders)) + os.linesep) # ghi độ dài list orders vào file
        elif line == "?total_revenue": # nếu yêu cầu là total_revenue
            output_file.write(str(total_revenue) + os.linesep)  # ghi tổng doanh thu vào file
        elif line.startswith("?revenue_of_shop"): # nếu yêu cầu là revenue_of_shop
            shop_id = line.split()[1] # lấy id cửa hàng
            output_file.write(str(shops_revenue[shop_id]) + os.linesep) # ghi doanh thu của id đó vào file
        elif line.startswith("?total_consume_of_customer_shop"): # nếu yêu cầu total_consume_of_customer_shop
            parts = line.split() #lấy phần đầu
            customer_id = parts[1] # lấy id khách
            shop_id = parts[2] # lấy id cửa hàng
            output_file.write(str(customers_shops_revenue[(customer_id, shop_id)]) + os.linesep) # ghi theo yêu cầu vào file
        elif line.startswith("?total_revenue_in_period"): # nếu yêu cầu total_revenue_in_period
            parts = line.split() # lấy phẩn đầu
            from_time = time_to_seconds(parts[1]) # lấy thời gian bắt đầu
            to_time = time_to_seconds(parts[2]) # lấy thời gian kết thúc
            revenue_period = sum(price for (_, _, price, _, time) in orders if from_time <= time_to_seconds(time) <= to_time) # tính tổng bằng sum kết hợp vòng lặp
            output_file.write(str(revenue_period) + os.linesep) # ghi kết quả vào file
`, "8_1":`# Nguyễn Nam Hoàng - 20215382
# Gọi module datetime để làm việc với ngày và giờ
import os
from datetime import datetime

# hàm phân tích dòng nộp bài
def parse_submission(line):
    user, problem, time_str, status, point = line.split()
    time_point = datetime.strptime(time_str, "%H:%M:%S")  # Chuyển đổi chuỗi thời gian thành đối tượng datetime
    return user, problem, time_point, status, int(point) # trả về các thông tin input

# Hàm để xử lý các truy vấn dựa trên các bài nộp
def process_queries(submissions, queries):
    max_points = {} # lưu điểm nhiều nhất 1 bài
    total_submissions = 0 # lưu số lần nộp 
    error_submissions = 0 # lưu số lần nộp bị lỗi
    user_error_submissions = {} # lưu số lần nộp bị lỗi của 1 user
    user_total_points = {} # lưu số điểm 1 user

    # lặp qua từng bài nộp
    for submission in submissions:
        user, problem, time_point, status, point = submission
        total_submissions += 1  # tăng số lượng bài nộp tổng

        # kiểm tra xem bài nộp có trạng thái lỗi không
        if status == 'ERR':
            error_submissions += 1  # Tăng số lượng bài nộp lỗi
            # theo dõi số lượng bài nộp lỗi cho từng người dùng
            if user not in user_error_submissions:
                user_error_submissions[user] = 1 # nếu lần đầu, gán = 1
            else:
                user_error_submissions[user] += 1 # nếu không phải, tăng biến lên 1

        # cập nhật điểm tối đa cho từng cặp (người dùng, bài) cập nhật khi người dùng chưa có trong danh sách hoặc điểm của 1 bài cao hơn
        if (user, problem) not in user_total_points or point > user_total_points[(user, problem)]:
            user_total_points[(user, problem)] = point

        # cập nhật điểm tối đa cho từng bài
        if problem not in max_points or point > max_points[problem]:
            max_points[problem] = point # gán bằng điểm point

    # xử lý từng truy vấn và lưu kết quả
    results = [] # list lưu kết quả
    for query in queries: # lặp qua từng truy vấn
        if query == '?total_number_submissions': # kiểm tra loại truy vấn
            results.append(str(total_submissions)) # chèn kết quả vào list
        elif query == '?number_error_submision': # kiểm tra loại truy vấn
            results.append(str(error_submissions)) # chèn kết quả vào list
        elif query.startswith('?number_error_submision_of_user'): # kiểm tra loại truy vấn
            _, user_query = query.split() # lấy tên user
            results.append(str(user_error_submissions.get(user, 0))) # chèn kết quả vào list
        elif query.startswith('?total_point_of_user'): # kiểm tra loại truy vấn
            _, user_query = query.split() # lấy tên user
            user_points = [point for (u, p), point in user_total_points.items() if u == user] # lặp để tính tổng điểm 1 user
            results.append(str(sum(user_points))) # chèn kết quả vào list
        elif query.startswith('?number_submission_period'): # kiểm tra loại truy vấn
            _, from_time, to_time = query.split() # lấy from_time, to_time
            from_time = datetime.strptime(from_time, "%H:%M:%S") # chuyển đổi về dạng thời gian
            to_time = datetime.strptime(to_time, "%H:%M:%S") # chuyển đổi về dạng thời gian
            submissions_in_period = sum(1 for _, _, time_point, _, _ in submissions if from_time <= time_point <= to_time)# đếm số lượng bài nộp trong khoảng thời gian chỉ định
            results.append(str(submissions_in_period)) # chèn kết quả vào list

    return results # trả về kết quả

if __name__ == "__main__":
    submissions = [] # list lưu thông tin nộp bài

    # vòng lặp nhập 
    while True:
        line = input().strip()   # lấy các dòng nhập
        if line == '#': # gặp '#' thì break
            break
        submissions.append(parse_submission(line)) # chèn dữ liệu

    queries = [] # list lưu truy vấn

    # vòng lặp nhập để đọc các truy vấn
    while True:
        line = input().strip() # lấy các dòng nhập
        if line == '#':# gặp '#' thì break
            break
        queries.append(line) # chèn dữ liệu

    results = process_queries(submissions, queries)  # xử lý truy vấn 

    # Ghi kết quả vào file 'temp.txt'
    with open('temp/temp.txt', 'w') as output_file:
        output_file.write("Nguyễn Nam Hoàng" + os.linesep)
        for result in results:
            output_file.write(result + os.linesep) # ghi kết quả vào file

`, "8_2":`# Nguyễn Nam Hoàng - 20215382
import os
from datetime import datetime

# định nghĩa lớp Person để biểu diễn thông tin về mỗi người
class Person:
    def __init__(self, code, date_of_birth, father_code, mother_code, is_alive, region_code): # hàm khởi tạo cùng các phép gán
        self.code = code 
        try:
            self.date_of_birth = datetime.strptime(date_of_birth, "%Y-%m-%d") # đưa ngày sinh dạng chuỗi về dạng date
        except ValueError:
            # Xử lý nếu ngày sinh không hợp lệ bằng cách sử dụng giá trị mặc định
            self.date_of_birth = datetime.strptime('2999-01-01', "%Y-%m-%d") # đưa ngày sinh dạng chuỗi về dạng date
        self.father_code = father_code
        self.mother_code = mother_code
        self.is_alive = is_alive
        self.region_code = region_code

# hàm phân tích dòng đầu vào và trả về đối tượng Person tương ứng
def parse_submission(line):
    parts = line.split() # lấy từng phần 1 dòng
    code, date_of_birth, father_code, mother_code, is_alive, region_code = parts # gán từng phần cho từng nội dung cụ thể

    return Person(code, date_of_birth, father_code, mother_code, is_alive, region_code) # trả về 1 đối tượng Person

# hàm  phân tích đầu vào của chương trình
def parse_input():
    submissions = {} # lưu Person

    # đọc thông tin người 
    while True:
        line = input().strip() # nhập 1 dòng
        if line == '*': 
            break # gặp dấu '*' thì break
        person = parse_submission(line) # lấy thông tin Person
        submissions[person.code] = person # lưu thông tin Person

    queries = [] # lưu các truy vấn

    # đọc các truy vấn 
    while True:
        line = input().strip() # nhập 1 dòng
        if line == '***':
            break # gặp *** thì dừng
        queries.append(line) # đưa dòng nhập vào list các truy vấn
    return submissions, queries # trả về input

# hàm trả về số lượng người trong cơ sở dữ liệu
def number_people(database):
    return len(database)  # độ dài của database

# hàm trả về số lượng người sinh vào một ngày cụ thể
def number_people_born_at(database, date):
    return sum(1 for person in database.values() if person.date_of_birth.strftime('%Y-%m-%d') == date) # tính tổng thông qua lặp tất cả mọi người

# hàm trả về người tổ tiên sống lâu nhất của một người
def most_alive_ancestor(database, code):
    def find_ancestor(person):
        if person.father_code == '0000000' and person.mother_code == '0000000': # nếu không có thông tin cha mẹ
            return 0 # trả về 0
        father = database[person.father_code] # lấy thông tin cha
        mother = database[person.mother_code] # lấy thông tin mẹ
        return max(find_ancestor(father), find_ancestor(mother)) + 1 # lấy max của hàm đệ quy

    person = database[code] # gán thông tin người
    return find_ancestor(person) # trả về kết quả

# hàm trả về số lượng người sinh trong khoảng thời gian cụ thể
def number_people_born_between(database, from_date, to_date):
    from_date = datetime.strptime(from_date, "%Y-%m-%d") # lấy ngày bắt đầu
    to_date = datetime.strptime(to_date, "%Y-%m-%d") # lấy ngày kết thúc
    return sum(1 for person in database.values() if from_date <= person.date_of_birth <= to_date) # tính kết quả dựa vào vòng lặp với điều kiện cụ thể

# hàm trả về số lượng người không có mối quan hệ họ hàng lớn nhất
def max_unrelated_people(database):
    # lấy list mã số của tất cả người trong database
    codes = list(database.keys())
    max_size = 0 # gán biến kết quả = 0

    # lặp qua tất cả cặp mã số để kiểm tra mối quan hệ họ hàng
    for code1 in codes:
        for code2 in codes:
            # kiểm tra mã số khác nhau để tránh so sánh với chính bản thân
            if code1 != code2:
                # kiểm tra mối quan hệ họ hàng giữa tất cả các người trong cơ sở dữ liệu
                unrelated = all(
                    (database[p].father_code != code1 or database[p].mother_code != code2) and
                    (database[p].father_code != code2 or database[p].mother_code != code1) for p in codes
                )
                # nếu không có mối quan hệ họ hàng, cập nhật kích thước lớn nhất
                if unrelated:
                    max_size = max(max_size, len({code1, code2}))

    # trả về kích thước lớn nhất của nhóm người không có mối quan hệ họ hàng
    return max_size

# hàm xử lý các truy vấn và ghi kết quả vào tệp 'temp.txt'
def process_queries(database, queries):
    results = [] # list lưu kết quả

    for query in queries: # lặp qua các truy vấn
        if query == 'NUMBER_PEOPLE': # kiểm tra thông tin truy vấn
            results.append(number_people(database)) # chèn kết quả vào list
        elif query.startswith('NUMBER_PEOPLE_BORN_AT'): # kiểm tra thông tin truy vấn
            _, date = query.split() # lưu ngày sinh
            results.append(number_people_born_at(database, date))  # chèn kết quả vào list
        elif query.startswith('MOST_ALIVE_ANCESTOR'): # kiểm tra thông tin truy vấn
            _, code = query.split() # lưu mã số
            results.append(most_alive_ancestor(database, code)) # chèn kết quả vào list
        elif query.startswith('NUMBER_PEOPLE_BORN_BETWEEN'): # kiểm tra thông tin truy vấn
            _, from_date, to_date = query.split() # lưu thời gian
            results.append(number_people_born_between(database, from_date, to_date)) # chèn kết quả vào list
        elif query == 'MAX_UNRELATED_PEOPLE': # kiểm tra thông tin truy vấn
            results.append(max_unrelated_people(database)) # chèn kết quả vào list

    # Ghi kết quả vào file 'temp.txt'
    with open('temp/temp.txt', 'w') as output_file:
        output_file.write("Nguyễn Nam Hoàng" + os.linesep)
        for result in results:
            output_file.write(str(result) + os.linesep)

# Hàm chính của chương trình
if __name__ == "__main__":
    submissions, queries = parse_input() # lấy input
    process_queries(submissions, queries) # xử lý và ghi kết quả vào 'temp.txt'

`
  };

  function showCode() {
      var weekSelector = document.getElementById("weekSelector").value;
      var baiSelector = document.getElementById("baiSelector").value;

      var key = weekSelector + "_" + baiSelector;

      document.getElementById("code").textContent = codeSnippets[key];
      document.getElementById("output").textContent = null
      document.getElementById("input").textContent = null
      document.getElementById("problem").textContent = problemStatements[key];
  }

  
  </script>
</body>
</html>
